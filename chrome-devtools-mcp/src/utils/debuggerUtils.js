/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{clearParseResultCache as t}from"../tools/analysis.js";import{getCdpSession as a}from"./cdp.js";import{cacheScript as r,clearScriptCache as n}from"./smartBreakpointUtils.js";const i=new WeakMap;export function getDebuggerState(e){let t=i.get(e);return t||(t={enabled:!1,isPaused:!1,activeBreakpointIds:new Set,userDisabled:!1},i.set(e,t)),t}export async function getActiveBreakpoints(e){const t=getDebuggerState(e),r=(await a(e),[]),n=[];for(const e of t.activeBreakpointIds)try{const t=e.split(":");if(t.length>=4){const a=parseInt(t[0],10)+1,n=parseInt(t[1],10),i=t.slice(3).join(":");r.push({breakpointId:e,url:i,lineNumber:a,columnNumber:n})}else r.push({breakpointId:e,url:"(unknown)",lineNumber:0,columnNumber:0})}catch{n.push(e)}for(const e of n)t.activeBreakpointIds.delete(e);return r}export function trackBreakpoint(e,t){getDebuggerState(e).activeBreakpointIds.add(t)}export function untrackBreakpoint(e,t){getDebuggerState(e).activeBreakpointIds.delete(t)}export function getBreakpointCount(e){return getDebuggerState(e).activeBreakpointIds.size}export function clearTrackedBreakpoints(e){getDebuggerState(e).activeBreakpointIds.clear()}const o=new WeakSet;export async function restoreBreakpointsAfterNavigation(t,a){const r=getDebuggerState(t);if(r.userDisabled)e("[debugger] Debugger was explicitly disabled by user, skipping re-enable after navigation");else try{await a.send("Debugger.enable"),r.enabled=!0,e("[debugger] Debugger re-enabled after navigation")}catch{}}export async function initializeDebuggerForPage(i){const s=await a(i),c=getDebuggerState(i);if(c.userDisabled=!1,c.enabled||(await s.send("Debugger.enable"),c.enabled=!0,s.on("Debugger.scriptParsed",async t=>{const a=t.scriptId,n=t.url||"";r(s,{scriptId:a,url:n,startLine:t.startLine,startColumn:t.startColumn,endLine:t.endLine,endColumn:t.endColumn}),e(`[debugger] Script parsed: ${n||a}`)}),s.on("Debugger.paused",t=>{c.isPaused=!0,c.pausedCallFrames=t.callFrames?.map(e=>({callFrameId:e.callFrameId,functionName:e.functionName||"(anonymous)",location:{scriptId:e.location.scriptId,lineNumber:e.location.lineNumber,columnNumber:e.location.columnNumber},url:e.url||"",scopeChain:e.scopeChain?.map(e=>({type:e.type,object:{type:e.object?.type,objectId:e.object?.objectId},name:e.name}))||[]})),e("[debugger] Execution paused at breakpoint")}),s.on("Debugger.resumed",()=>{c.isPaused=!1,c.pausedCallFrames=void 0,e("[debugger] Execution resumed")})),!o.has(i)){let a;o.add(i);try{const e=await s.send("Page.getFrameTree");a=e.frameTree?.frame?.id}catch{}s.on("Page.frameStartedLoading",async r=>{let o=!a||r.frameId===a;if(!o)try{const e=await s.send("Page.getFrameTree"),t=e.frameTree?.frame?.id;r.frameId===t&&(o=!0,a=t)}catch{o=!0}if(o){n(s),t(s),e("[debugger] Script cache and parse result cache cleared on navigation"),e("[debugger] Main frame started loading, initializing debugger/breakpoints...");try{await restoreBreakpointsAfterNavigation(i,s)}catch(t){e(`[debugger] Error restoring breakpoints: ${t}`)}try{const e=await s.send("Page.getFrameTree");a=e.frameTree?.frame?.id}catch{}}});try{await s.send("Page.enable")}catch{}}return s}export async function getBreakpointSummary(e){const t=await getActiveBreakpoints(e),a=[];if(0===t.length)return a;a.push(`ðŸ”´ Active breakpoints (${t.length}):`);for(const e of t){const t=`line ${e.lineNumber}, col ${e.columnNumber}`,r=e.condition?` [condition: ${e.condition}]`:"";a.push(`   â€¢ ${e.breakpointId}: ${e.url} @ ${t}${r}`)}return a}
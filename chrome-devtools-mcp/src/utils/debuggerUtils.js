/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{getCdpSession as t}from"./cdp.js";import{cacheScript as r,clearScriptCache as a}from"./smartBreakpointUtils.js";import{clearParseResultCache as n}from"../tools/analysis.js";import{ScriptCacheRegistry as i}from"./scriptCacheRegistry.js";const o=new WeakMap;export function getDebuggerState(e){let t=o.get(e);return t||(t={enabled:!1,isPaused:!1,activeBreakpointIds:new Set},o.set(e,t)),t}export async function getActiveBreakpoints(e){const r=getDebuggerState(e),a=(await t(e),[]),n=[];for(const e of r.activeBreakpointIds)try{const t=e.split(":");if(t.length>=4){const r=parseInt(t[0],10)+1,n=parseInt(t[1],10),i=t.slice(3).join(":");a.push({breakpointId:e,url:i,lineNumber:r,columnNumber:n})}else a.push({breakpointId:e,url:"(unknown)",lineNumber:0,columnNumber:0})}catch{n.push(e)}for(const e of n)r.activeBreakpointIds.delete(e);return a}export function trackBreakpoint(e,t){getDebuggerState(e).activeBreakpointIds.add(t)}export function untrackBreakpoint(e,t){getDebuggerState(e).activeBreakpointIds.delete(t)}export function getBreakpointCount(e){return getDebuggerState(e).activeBreakpointIds.size}export function clearTrackedBreakpoints(e){getDebuggerState(e).activeBreakpointIds.clear()}const c=new WeakSet;export async function restoreBreakpointsAfterNavigation(t,r){try{await r.send("Debugger.enable"),e("[debugger] Debugger re-enabled after navigation")}catch{}}export async function initializeDebuggerForPage(o){const s=await t(o),u=getDebuggerState(o);if(u.enabled||(await s.send("Debugger.enable"),u.enabled=!0,s.on("Debugger.scriptParsed",async t=>{const a=t.scriptId,n=t.url||"";if(r(s,{scriptId:a,url:n,startLine:t.startLine,startColumn:t.startColumn,endLine:t.endLine,endColumn:t.endColumn}),n)try{const e=(await s.send("Debugger.getScriptSource",{scriptId:a})).scriptSource;if(e){const t=i.getOrCreate(s);await t.cacheScript(a,n,e)}}catch(t){e(`[debugger] Failed to cache script source for ${a}: ${t}`)}e(`[debugger] Script parsed: ${n||a}`)}),s.on("Debugger.paused",t=>{u.isPaused=!0,u.pausedCallFrames=t.callFrames?.map(e=>({callFrameId:e.callFrameId,functionName:e.functionName||"(anonymous)",location:{scriptId:e.location.scriptId,lineNumber:e.location.lineNumber,columnNumber:e.location.columnNumber},url:e.url||"",scopeChain:e.scopeChain?.map(e=>({type:e.type,object:{type:e.object?.type,objectId:e.object?.objectId},name:e.name}))||[]})),e("[debugger] Execution paused at breakpoint")}),s.on("Debugger.resumed",()=>{u.isPaused=!1,u.pausedCallFrames=void 0,e("[debugger] Execution resumed")})),!c.has(o)){let t;c.add(o);try{const e=await s.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}s.on("Page.frameStartedLoading",async r=>{let i=!t||r.frameId===t;if(!i)try{const e=await s.send("Page.getFrameTree"),a=e.frameTree?.frame?.id;r.frameId===a&&(i=!0,t=a)}catch{i=!0}if(i){a(s),n(s),e("[debugger] Script cache and parse result cache cleared on navigation"),e("[debugger] Main frame started loading, initializing debugger/breakpoints...");try{await restoreBreakpointsAfterNavigation(o,s)}catch(t){e(`[debugger] Error restoring breakpoints: ${t}`)}try{const e=await s.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}}});try{await s.send("Page.enable")}catch{}}return s}export async function getBreakpointSummary(e){const t=await getActiveBreakpoints(e),r=[];if(0===t.length)return r;r.push(`ðŸ”´ Active breakpoints (${t.length}):`);for(const e of t){const t=`line ${e.lineNumber}, col ${e.columnNumber}`,a=e.condition?` [condition: ${e.condition}]`:"";r.push(`   â€¢ ${e.breakpointId}: ${e.url} @ ${t}${a}`)}return r}
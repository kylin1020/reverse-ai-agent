/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as n}from"../third_party/index.js";import{getCdpSession as t}from"../utils/cdp.js";import{initializeDebuggerForPage as s}from"../utils/debuggerUtils.js";import{getScriptCache as r}from"../utils/smartBreakpointUtils.js";import{ToolCategory as a}from"./categories.js";import{defineTool as i}from"./ToolDefinition.js";const o=new WeakMap,p=new WeakSet;let c=0;function d(e){let n=o.get(e);return n||(n=new Map,o.set(e,n)),n}async function l(n,t){const s=d(t);if(0===s.size){try{await n.send("Fetch.disable"),e("[intercept] Fetch disabled (no rules)")}catch{}return}const r=[];for(const e of s.values())r.push({urlPattern:e.matchedUrl,requestStage:"Response"});await n.send("Fetch.enable",{patterns:r}),e(`[intercept] Fetch enabled with ${r.length} URL(s)`)}async function u(n){const s=await t(n);if(p.has(n))return s;let r;p.add(n),s.on("Fetch.requestPaused",t=>{!async function(n,t,s){const{requestId:r,request:a}=s,i=a.url,o=d(t);let p;for(const e of o.values())if(e.matchedUrl===i){p=e;break}if(p)try{const t=await n.send("Fetch.getResponseBody",{requestId:r});let s;if(s=t.base64Encoded?Buffer.from(t.body,"base64").toString("utf-8"):t.body,!s.includes(p.oldCode))return e(`[intercept] âŒ Old code not found in ${i}`),void await n.send("Fetch.fulfillRequest",{requestId:r,responseCode:200,responseHeaders:[{name:"Content-Type",value:"application/javascript"}],body:t.body});const a=s.replace(p.oldCode,p.newCode),o=Buffer.from(a).toString("base64");await n.send("Fetch.fulfillRequest",{requestId:r,responseCode:200,responseHeaders:[{name:"Content-Type",value:"application/javascript"}],body:o}),e(`[intercept] âœ… Replaced code in ${i}`)}catch(t){e(`[intercept] Error: ${t}`);try{await n.send("Fetch.continueRequest",{requestId:r})}catch{}}else try{await n.send("Fetch.continueRequest",{requestId:r})}catch(n){e(`[intercept] Failed to continue request: ${n}`)}}(s,n,t)});try{const e=await s.send("Page.getFrameTree");r=e.frameTree?.frame?.id}catch{}s.on("Page.frameStartedLoading",async t=>{if(0===d(n).size)return;let a=!r||t.frameId===r;if(!a)try{const e=await s.send("Page.getFrameTree"),n=e.frameTree?.frame?.id;t.frameId===n&&(a=!0,r=n)}catch{a=!0}if(a){e("[intercept] Main frame loading, re-enabling Fetch interception...");try{await l(s,n)}catch(n){e(`[intercept] Error re-enabling Fetch: ${n}`)}}});try{await s.send("Page.enable")}catch{}return e("[intercept] Fetch interception initialized"),s}export const replaceScript=i({name:"replace_script",description:"Replace a JavaScript code snippet in scripts matching a URL pattern. Uses network interception to modify scripts before execution.\n\n**IMPORTANT:** Changes take effect after page refresh. Rules persist across page refreshes until removed.\n\nThis tool:\n1. Finds loaded scripts matching the URL pattern (regex)\n2. Registers an interception rule for the matched script URL\n3. On page refresh, intercepts and modifies the script\n\nIf no scripts match the pattern or old code is not found, an error is reported.\n\nUse cases:\n- Modify third-party scripts\n- Inject debugging code\n- Bypass anti-debugging measures\n- Test code changes without modifying source",annotations:{category:a.DEBUGGING,readOnlyHint:!1},schema:{urlPattern:n.string().describe('URL pattern (regex) to match scripts. Examples: ".*main\\.js.*", ".*jquery.*"'),oldCode:n.string().describe("The original code snippet to replace. Must match exactly."),newCode:n.string().describe("The new code snippet.")},handler:async(e,n,t)=>{const{urlPattern:a,oldCode:i,newCode:o}=e.params,p=t.getSelectedPage();if(!i.trim())return void n.appendResponseLine("âŒ Error: oldCode cannot be empty.");if(i===o)return void n.appendResponseLine("âŒ Error: oldCode and newCode are identical.");const f=await s(p,{forceEnable:!0}),h=r(f);let m;try{m=new RegExp(a,"i")}catch(e){return void n.appendResponseLine(`âŒ Error: Invalid URL pattern: ${e}`)}const g=[];for(const[e,n]of h.entries())n.url&&m.test(n.url)&&g.push({scriptId:e,url:n.url});if(0===g.length)return n.appendResponseLine(`âŒ Error: No loaded scripts match "${a}"`),n.appendResponseLine(""),n.appendResponseLine("ðŸ’¡ Tips:"),n.appendResponseLine("   â€¢ Ensure the script is loaded"),void n.appendResponseLine('   â€¢ Use `list_network_requests` with resourceTypes=["script"]');if(g.length>1){n.appendResponseLine("âš ï¸ Multiple scripts match. Using first:");for(const e of g.slice(0,3))n.appendResponseLine(`   â€¢ ${e.url}`);g.length>3&&n.appendResponseLine(`   ... and ${g.length-3} more`),n.appendResponseLine("")}const R=g[0],L=`rule_${Date.now()}_${++c}`,y={id:L,urlPattern:a,matchedUrl:R.url,oldCode:i,newCode:o,createdAt:Date.now()};d(p).set(L,y);const w=await u(p);await l(w,p),n.appendResponseLine("âœ… Script replacement rule registered."),n.appendResponseLine(""),n.appendResponseLine(`**Rule ID:** \`${L}\``),n.appendResponseLine(`**Matched URL:** ${R.url}`),n.appendResponseLine(`**Old Code:** \`${i.substring(0,50)}${i.length>50?"...":""}\``),n.appendResponseLine(`**New Code:** \`${o.substring(0,50)}${o.length>50?"...":""}\``),n.appendResponseLine(""),n.appendResponseLine("âš ï¸ **Refresh the page** for the replacement to take effect.")}});export const listScriptReplacements=i({name:"list_script_replacements",description:"List all active script replacement rules for the current page.",annotations:{category:a.DEBUGGING,readOnlyHint:!0},schema:{},handler:async(e,n,t)=>{const s=d(t.getSelectedPage());if(0===s.size)return n.appendResponseLine("ðŸ“‹ No script replacement rules."),void n.appendResponseLine("Use `replace_script` to add one.");n.appendResponseLine(`ðŸ“‹ **${s.size} rule${1===s.size?"":"s"}:**`),n.appendResponseLine("");for(const e of s.values())n.appendResponseLine("---"),n.appendResponseLine(`**ID:** \`${e.id}\``),n.appendResponseLine(`**Pattern:** ${e.urlPattern}`),n.appendResponseLine(`**URL:** ${e.matchedUrl}`),n.appendResponseLine("**Old Code:**"),n.appendResponseLine("```javascript"),n.appendResponseLine(e.oldCode.length>200?e.oldCode.substring(0,200)+"...":e.oldCode),n.appendResponseLine("```"),n.appendResponseLine("**New Code:**"),n.appendResponseLine("```javascript"),n.appendResponseLine(e.newCode.length>200?e.newCode.substring(0,200)+"...":e.newCode),n.appendResponseLine("```")}});export const removeScriptReplacement=i({name:"remove_script_replacement",description:"Remove a script replacement rule by its ID.",annotations:{category:a.DEBUGGING,readOnlyHint:!1},schema:{ruleId:n.string().describe("The rule ID to remove.")},handler:async(e,n,s)=>{const{ruleId:r}=e.params,a=s.getSelectedPage(),i=d(a);if(!i.has(r))return n.appendResponseLine(`âŒ Rule not found: \`${r}\``),void n.appendResponseLine("Use `list_script_replacements` to see active rules.");i.delete(r);const o=await t(a);await l(o,a),n.appendResponseLine(`âœ… Rule removed: \`${r}\``)}});export const clearScriptReplacements=i({name:"clear_script_replacements",description:"Remove all script replacement rules for the current page.",annotations:{category:a.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,s)=>{const r=s.getSelectedPage(),a=d(r),i=a.size;if(0===i)return void n.appendResponseLine("ðŸ“‹ No rules to clear.");a.clear();const o=await t(r);await l(o,r),n.appendResponseLine(`âœ… Cleared ${i} rule${1===i?"":"s"}.`)}});
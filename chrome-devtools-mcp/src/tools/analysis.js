/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{zod as e}from"../third_party/index.js";import{getCdpSession as n}from"../utils/cdp.js";import{paginate as t}from"../utils/pagination.js";import{analyzeFunction as s,buildCallGraph as a}from"./callGraphAnalyzer.js";import{ToolCategory as o}from"./categories.js";import{extractContextCode as i,formatMinifiedCode as r,isMinified as p,formatPositionAnnotation as c}from"./contextCodeUtils.js";import{parseScript as l}from"./scriptParser.js";import{searchInScripts as d}from"./scriptSearcher.js";import{getAllScriptsWithSource as u}from"./smartBreakpointUtils.js";import{defineTool as f}from"./ToolDefinition.js";const m=new WeakMap,h=new WeakMap;function g(e){let n=m.get(e);return n||(n=new Map,m.set(e,n)),n}function L(e,n,t,s){const a=g(e),o=a.get(n);if(o)return o;const i=l(n,t,s);return a.set(n,i),h.delete(e),i}export function clearParseResultCache(e){g(e).clear(),h.delete(e)}function R(e,n="",t=!0){const s=Object.entries(e);if(0===s.length)return"";let a="";return s.forEach(([e,o],i)=>{const r=i===s.length-1,p=t?"    ":"â”‚   ";a+=`${n}${t?"â””â”€â”€ ":"â”œâ”€â”€ "}${e}\n`,"Leaf"!==o&&Object.keys(o).length>0&&(a+=R(o,n+p,r))}),a}export const analyzeCallGraph=f({name:"analyze_call_graph",description:'Analyze the call graph for a specific JavaScript function to understand its callers (upstream) and callees (downstream).\n\nThis tool parses all loaded scripts, builds a call graph, and traces the relationships for the specified function.\nUseful for reverse engineering and understanding code flow without reading the actual implementation.\n\nExample:\n- Analyze function "handleClick": functionName="handleClick"\n- Analyze with deeper trace: functionName="processData", upstreamDepth=5, downstreamDepth=5\n- Filter to specific file: functionName="init", urlPattern=".*main\\.js.*"',annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{functionName:e.string().describe("The name of the function to analyze."),upstreamDepth:e.number().int().min(0).max(10).optional().default(3).describe("Maximum depth for upstream trace (callers). Default: 3, Max: 10."),downstreamDepth:e.number().int().min(0).max(10).optional().default(3).describe("Maximum depth for downstream trace (callees). Default: 3, Max: 10."),urlPattern:e.string().optional().describe("Optional regex pattern to filter scripts by URL.")},handler:async(e,t,o)=>{const{functionName:i,upstreamDepth:r,downstreamDepth:p,urlPattern:c}=e.params,l=o.getSelectedPage(),d=await n(l);t.appendResponseLine(`Analyzing call graph for function: ${i}`),t.appendResponseLine("");const f=await u(d,c);if(0===f.size)return t.appendResponseLine("âŒ No scripts found."),c&&t.appendResponseLine(`   URL pattern: ${c}`),t.appendResponseLine(""),t.appendResponseLine("ðŸ’¡ Suggestions:"),t.appendResponseLine("   â€¢ Ensure the page has loaded JavaScript files"),void t.appendResponseLine("   â€¢ Check that the URL pattern is correct");t.appendResponseLine(`ðŸ“œ Parsed ${f.size} script(s)`);const m=[];let h=0,g=0,x=0;for(const[e,{url:n,source:t}]of f){const s=L(d,e,n,t);m.push(s),h+=s.functions.length,g+=s.calls.length,x+=s.errors.length}t.appendResponseLine(`ðŸ“Š Found ${h} functions, ${g} call relationships`),x>0&&t.appendResponseLine(`âš ï¸ ${x} parse error(s) encountered`),t.appendResponseLine("");const b=a(m),$=s(b,i,r,p);if(!$.found){if(t.appendResponseLine(`âŒ Function "${i}" not found in any script.`),t.appendResponseLine(""),$.similarFunctions&&$.similarFunctions.length>0){t.appendResponseLine("ðŸ’¡ Similar functions found:");for(const e of $.similarFunctions){const n=b.functions.get(e);n?t.appendResponseLine(`   â€¢ ${e} (${n.scriptUrl}:${n.lineNumber})`):t.appendResponseLine(`   â€¢ ${e}`)}}return}if($.functionInfo){const e=$.functionInfo;t.appendResponseLine(`âœ… Function found: ${e.name}`),t.appendResponseLine(`   Location: ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`),t.appendResponseLine(`   Type: ${e.type}`),t.appendResponseLine(`   Parameters: ${e.params.length>0?e.params.join(", "):"(none)"}`)}t.appendResponseLine("");const y=Object.keys($.upstream);t.appendResponseLine(`ðŸ“¥ Upstream (who calls ${i}): ${y.length} direct caller(s)`),y.length>0?t.appendResponseLine(R($.upstream)):t.appendResponseLine("   (no callers found)"),t.appendResponseLine("");const z=Object.keys($.downstream);t.appendResponseLine(`ðŸ“¤ Downstream (what ${i} calls): ${z.length} direct callee(s)`),z.length>0?t.appendResponseLine(R($.downstream)):t.appendResponseLine("   (no callees found)")}});export const searchScriptContent=f({name:"search_script_content",description:'Search for code snippets or patterns across all loaded JavaScript files.\n\nSupports both plain text and regular expression searches. Returns matches with script URL,\nline number, column, and surrounding context. Useful for finding specific code patterns\nin potentially obfuscated code.\n\nExample:\n- Search for text: pattern="addEventListener"\n- Search with regex: pattern="function\\s+\\w+\\(", isRegex=true\n- Filter by URL: pattern="fetch", urlPattern=".*api\\.js.*"',annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{pattern:e.string().describe("The search pattern (string or regex)."),isRegex:e.boolean().optional().default(!1).describe("Whether to treat the pattern as a regular expression. Default: false."),urlPattern:e.string().optional().describe("Optional regex pattern to filter scripts by URL."),formatContext:e.boolean().optional().default(!0).describe("Whether to apply AST-based formatting to the context for minified code. Default: true."),contextLines:e.number().int().nonnegative().optional().default(3).describe("Number of context lines to show around each match. Default: 3."),pageSize:e.number().int().positive().optional().describe("Maximum number of matches to return per page."),pageIdx:e.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,s,a)=>{const{pattern:o,isRegex:l,urlPattern:f,formatContext:m,contextLines:h,pageSize:g,pageIdx:L}=e.params,R=a.getSelectedPage(),b=await n(R);if(!o)return void s.appendResponseLine("âŒ Search pattern is required.");if(l)try{new RegExp(o)}catch(e){return s.appendResponseLine(`âŒ Invalid regular expression: ${o}`),void s.appendResponseLine(`   Error: ${e instanceof Error?e.message:String(e)}`)}const $=await u(b,f);if(0===$.size)return s.appendResponseLine("âŒ No scripts found."),void(f&&s.appendResponseLine(`   URL pattern: ${f}`));const y=new Map;for(const[e,{url:n,source:t}]of $)y.set(e,{url:n,source:t});const z=d(y,o,l);if(0===z.totalMatches)return s.appendResponseLine(`ðŸ” No matches found for: ${o}`),void(l&&s.appendResponseLine("   (searched as regex)"));const w=t(z.matches,{pageSize:g,pageIdx:L});s.appendResponseLine(`ðŸ” Search results for: ${o}`),l&&s.appendResponseLine("   (regex search)"),s.appendResponseLine(`ðŸ“Š Total matches: ${z.totalMatches}`),w.totalPages>1&&(s.appendResponseLine(`ðŸ“„ Showing ${w.startIndex+1}-${w.endIndex} (Page ${w.currentPage+1} of ${w.totalPages})`),w.hasNextPage&&s.appendResponseLine(`   Next page: pageIdx=${w.currentPage+1}`)),s.appendResponseLine("");for(const e of w.items){s.appendResponseLine(`ðŸ“ ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`),s.appendResponseLine(`   Match: "${e.matchText}"`);const n=$.get(e.scriptId),t=n?.source;if(t&&m&&p(t)){const n=r(t);if(n.success){const t=i(n.formattedCode,{lineNumber:e.lineNumber,columnNumber:e.columnNumber,contextLines:h??3,formatMinified:!1});s.appendResponseLine("   Context (formatted):"),s.appendResponseLine("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");for(const n of t.lines){const t=n.isCurrentLine?">>>":"   ",a=String(n.displayLineNumber).padStart(4," "),o=c(n.originalLineNumber,0);let i=n.content;if(n.isCurrentLine&&e.matchText){const n=i.indexOf(e.matchText);n>=0&&(i=i.substring(0,n)+`ã€${e.matchText}ã€‘`+i.substring(n+e.matchText.length))}s.appendResponseLine(`   ${t}${a} â”‚ ${i}  ${o}`)}s.appendResponseLine("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")}else x(s,e)}else x(s,e);s.appendResponseLine("")}}});function x(e,n){const t=200;let s;if(n.context.length>t){const e=n.columnNumber,a=e+n.matchText.length,o=Math.floor((t-n.matchText.length)/2);let i=Math.max(0,e-o),r=Math.min(n.context.length,a+o);0===i?r=Math.min(n.context.length,t):r===n.context.length&&(i=Math.max(0,n.context.length-t));const p=i>0?"...":"",c=r<n.context.length?"...":"";s=p+n.context.substring(i,r)+c}else s=n.context;const a=s.replace(n.matchText,`ã€${n.matchText}ã€‘`);e.appendResponseLine(`   Context: ${a.trim()}`)}function b(e,n){const t=e.toLowerCase(),s=n.toLowerCase();if(t===s)return 1;if(s.includes(t))return.8;if(t.includes(s))return.7;const a=new Set(t),o=new Set(s);let i=0;for(const e of a)o.has(e)&&i++;return i/Math.max(a.size,o.size)}export const searchFunctions=f({name:"search_functions",description:'Search for function definitions by name across all loaded JavaScript files.\n\nSupports exact matching, pattern matching, and fuzzy matching to find similar function names.\nReturns function location, type, and parameters. Useful for locating function definitions\nin large or obfuscated codebases.\n\nExample:\n- Search for exact name: namePattern="handleClick"\n- Search with pattern: namePattern="handle.*", fuzzy=false\n- Fuzzy search: namePattern="onClick", fuzzy=true\n- Filter by URL: namePattern="init", urlPattern=".*main\\.js.*"',annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{namePattern:e.string().describe("The function name or pattern to search for."),urlPattern:e.string().optional().describe("Optional regex pattern to filter scripts by URL."),fuzzy:e.boolean().optional().default(!0).describe("Whether to use fuzzy matching for similar names. Default: true."),showCode:e.boolean().optional().default(!1).describe("Whether to display the formatted function body code. Default: false."),maxCodeLines:e.number().int().positive().optional().default(20).describe("Maximum lines of code to display per function. Default: 20."),pageSize:e.number().int().positive().optional().describe("Maximum number of functions to return per page."),pageIdx:e.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,s,a)=>{const{namePattern:o,urlPattern:i,fuzzy:l,showCode:d,maxCodeLines:f,pageSize:m,pageIdx:R}=e.params,x=a.getSelectedPage(),$=await n(x);if(!o)return void s.appendResponseLine("âŒ Function name pattern is required.");const y=await u($,i);if(0===y.size)return s.appendResponseLine("âŒ No scripts found."),void(i&&s.appendResponseLine(`   URL pattern: ${i}`));for(const[e,{url:n,source:t}]of y)L($,e,n,t);const z=function(e,n){const t=new Set(n.keys()),s=g(e),a=h.get(e);if(a&&t.size===s.size)return a;const o=[];for(const e of t){const n=s.get(e);n&&o.push(...n.functions)}if(t.size===s.size&&a){const n=[];for(const e of s.values())n.push(...e.functions);return h.set(e,n),n}return o}($,y);if(0===z.length)return void s.appendResponseLine("âŒ No functions found in loaded scripts.");let w=[],S=!1,P=null;try{/[.*+?^${}()|[\]\\]/.test(o)&&(P=new RegExp(o,"i"),S=!0)}catch{}if(S&&P)w=z.filter(e=>P.test(e.name));else{const e=o.toLowerCase();if(w=z.filter(n=>n.name.toLowerCase()===e),0===w.length&&l){w=z.map(e=>({func:e,score:b(o,e.name)})).filter(e=>e.score>=.3).sort((e,n)=>n.score-e.score).map(e=>e.func)}}if(0===w.length){s.appendResponseLine(`ðŸ” No functions found matching: ${o}`),l&&s.appendResponseLine("   (fuzzy search enabled)");const e=z.slice(0,5);if(e.length>0){s.appendResponseLine(""),s.appendResponseLine("ðŸ’¡ Sample functions in loaded scripts:");for(const n of e)s.appendResponseLine(`   â€¢ ${n.name} (${n.type})`)}return}const N=t(w,{pageSize:m,pageIdx:R});s.appendResponseLine(`ðŸ” Functions matching: ${o}`),S?s.appendResponseLine("   (regex pattern)"):l&&w.length>0&&s.appendResponseLine("   (fuzzy matching)"),s.appendResponseLine(`ðŸ“Š Total matches: ${w.length}`),N.totalPages>1&&(s.appendResponseLine(`ðŸ“„ Showing ${N.startIndex+1}-${N.endIndex} (Page ${N.currentPage+1} of ${N.totalPages})`),N.hasNextPage&&s.appendResponseLine(`   Next page: pageIdx=${N.currentPage+1}`)),s.appendResponseLine("");for(const e of N.items){if(s.appendResponseLine(`ðŸ“ ${e.name}`),s.appendResponseLine(`   Location: ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`),s.appendResponseLine(`   Type: ${e.type}`),s.appendResponseLine(`   Parameters: ${e.params.length>0?e.params.join(", "):"(none)"}`),d){const n=y.get(e.scriptId);if(n?.source){const t=n.source;let a=t,o=!1;if(p(t)){const e=r(t);e.success&&(a=e.formattedCode,o=!0)}const i=a.split("\n"),l=e.lineNumber-1,d=Math.min(l+(f??20),i.length),u=i.slice(l,d),m=i.length-l;s.appendResponseLine("   Code:"),o&&s.appendResponseLine("   (formatted from minified source)"),s.appendResponseLine("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");for(let n=0;n<u.length;n++){const t=l+n+1,a=(c(e.lineNumber,e.columnNumber),String(t).padStart(4," "));s.appendResponseLine(`   ${a} â”‚ ${u[n]}`)}m>(f??20)&&s.appendResponseLine(`   ... (${m-(f??20)} more lines, total: ${m})`),s.appendResponseLine("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")}}s.appendResponseLine("")}}});
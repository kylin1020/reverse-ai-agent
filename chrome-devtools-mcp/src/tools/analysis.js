/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{zod as e}from"../third_party/index.js";import{analyzeFunction as n,buildCallGraph as s}from"../utils/callGraphAnalyzer.js";import{getCdpSession as t}from"../utils/cdp.js";import{parseScript as a}from"../utils/scriptParser.js";import{getAllScriptsWithSource as o}from"../utils/smartBreakpointUtils.js";import{ToolCategory as p}from"./categories.js";import{defineTool as i}from"./ToolDefinition.js";const r=new WeakMap;function c(e){let n=r.get(e);return n||(n=new Map,r.set(e,n)),n}function l(e,n,s,t){const o=c(e),p=o.get(n);if(p)return p;const i=a(n,s,t);return o.set(n,i),i}export function clearParseResultCache(e){c(e).clear()}function d(e,n="",s=!0){const t=Object.entries(e);if(0===t.length)return"";let a="";return t.forEach(([e,o],p)=>{const i=p===t.length-1,r=s?"    ":"â”‚   ";a+=`${n}${s?"â””â”€â”€ ":"â”œâ”€â”€ "}${e}\n`,"Leaf"!==o&&Object.keys(o).length>0&&(a+=d(o,n+r,i))}),a}export const analyzeCallGraph=i({name:"analyze_call_graph",description:"Analyze the call graph for a specific JavaScript function to understand its callers and callees.",annotations:{category:p.DEBUGGING,readOnlyHint:!0},schema:{functionName:e.string().describe("The name of the function to analyze."),upstreamDepth:e.number().int().min(0).max(10).optional().default(3).describe("Maximum depth for upstream trace (callers). Default: 3, Max: 10."),downstreamDepth:e.number().int().min(0).max(10).optional().default(3).describe("Maximum depth for downstream trace (callees). Default: 3, Max: 10."),urlPattern:e.string().optional().describe("Optional regex pattern to filter scripts by URL.")},handler:async(e,a,p)=>{const{functionName:i,upstreamDepth:r,downstreamDepth:c,urlPattern:u}=e.params,f=p.getSelectedPage(),m=await t(f);a.appendResponseLine(`Analyzing call graph for function: ${i}`),a.appendResponseLine("");const h=await o(m,u);if(0===h.size)return a.appendResponseLine("âŒ No scripts found."),u&&a.appendResponseLine(`   URL pattern: ${u}`),a.appendResponseLine(""),a.appendResponseLine("ðŸ’¡ Suggestions:"),a.appendResponseLine("   â€¢ Ensure the page has loaded JavaScript files"),void a.appendResponseLine("   â€¢ Check that the URL pattern is correct");a.appendResponseLine(`ðŸ“œ Parsed ${h.size} script(s)`);const L=[];let R=0,g=0,$=0;for(const[e,{url:n,source:s}]of h){const t=l(m,e,n,s);L.push(t),R+=t.functions.length,g+=t.calls.length,$+=t.errors.length}a.appendResponseLine(`ðŸ“Š Found ${R} functions, ${g} call relationships`),$>0&&a.appendResponseLine(`âš ï¸ ${$} parse error(s) encountered`),a.appendResponseLine("");const y=s(L),b=n(y,i,r,c);if(!b.found){if(a.appendResponseLine(`âŒ Function "${i}" not found in any script.`),a.appendResponseLine(""),b.similarFunctions&&b.similarFunctions.length>0){a.appendResponseLine("ðŸ’¡ Similar functions found:");for(const e of b.similarFunctions){const n=y.functions.get(e);n?a.appendResponseLine(`   â€¢ ${e} (${n.scriptUrl}:${n.lineNumber})`):a.appendResponseLine(`   â€¢ ${e}`)}}return}if(b.functionInfo){const e=b.functionInfo;a.appendResponseLine(`âœ… Function found: ${e.name}`),a.appendResponseLine(`   Location: ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`),a.appendResponseLine(`   Type: ${e.type}`),a.appendResponseLine(`   Parameters: ${e.params.length>0?e.params.join(", "):"(none)"}`)}a.appendResponseLine("");const j=Object.keys(b.upstream);a.appendResponseLine(`ðŸ“¥ Upstream (who calls ${i}): ${j.length} direct caller(s)`),j.length>0?a.appendResponseLine(d(b.upstream)):a.appendResponseLine("   (no callers found)"),a.appendResponseLine("");const w=Object.keys(b.downstream);a.appendResponseLine(`ðŸ“¤ Downstream (what ${i} calls): ${w.length} direct callee(s)`),w.length>0?a.appendResponseLine(d(b.downstream)):a.appendResponseLine("   (no callees found)")}});
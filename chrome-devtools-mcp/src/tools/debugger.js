/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as n}from"../third_party/index.js";import{getCdpSession as t}from"../utils/cdp.js";import{getConfig as a}from"../utils/config.js";import{paginate as s}from"../utils/pagination.js";import{ToolCategory as o}from"./categories.js";import{getDebuggerState as i,initializeDebuggerForPage as r}from"../utils/debuggerUtils.js";import{findMatchingScripts as p,findNearestBreakpointLocation as l,queryPossibleBreakpoints as c,getScriptCache as d,getScriptSource as u}from"../utils/smartBreakpointUtils.js";import{defineTool as m}from"./ToolDefinition.js";import{extractContextCode as g,formatContextCodeOutput as b}from"../utils/contextCodeUtils.js";function f(e,n=a().maxInlineStringLength){const t=e.type||"unknown",s=e.subtype;if(void 0!==e.value){const s=function(e,n=a().maxInlineStringLength){if(void 0===e)return{formatted:"undefined",truncated:!1};if(null===e)return{formatted:"null",truncated:!1};let t;if("string"==typeof e)t=JSON.stringify(e);else if("object"==typeof e)try{t=JSON.stringify(e)}catch{t=String(e)}else t=String(e);return t.length>n?{formatted:t.substring(0,n)+"...",truncated:!0}:{formatted:t,truncated:!1}}(e.value,n);return{...s,type:t}}if(e.unserializableValue)return{formatted:e.unserializableValue,truncated:!1,type:t};if(e.preview){const a=e.preview;if(a.overflow){return{formatted:`{${(a.properties||[]).slice(0,5).map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}, ...}`,truncated:!0,type:s||t}}if(a.properties){const e=`{${a.properties.map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}}`;return e.length>n?{formatted:e.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:e,truncated:!1,type:s||t}}}if(e.description){const a=e.description;return a.length>n?{formatted:a.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:a,truncated:!1,type:s||t}}return{formatted:`[${s||t}]`,truncated:!1,type:s||t}}export function formatPreview(e){if(!e)return"[no preview]";if("object"===e.type){const n=e.properties||[];if(0===n.length)return"array"===e.subtype?"[]":"{}";const t=n.slice(0,3).map(e=>`${e.name}: ${e.value??e.type}`).join(", ");return"array"===e.subtype?e.overflow?`[${t}, ...]`:`[${t}]`:e.overflow?`{${t}, ...}`:`{${t}}`}return e.description||String(e.value??"[unknown]")}export async function inspectScopeVariablesOptimized(n,t,a){const s=[];let o=!1;if(a.skipScopeVariables)return s.push("   [Scope inspection skipped - use get_scope_variables for details]"),{lines:s,hasTruncatedValues:!1};const i=t.map(async t=>{if("global"===t.type)return{scopeName:"global",lines:["   [global] (use get_scope_variables to inspect)"],hasTruncatedValues:!1};const s=t.name?`${t.type}: ${t.name}`:t.type,o=[`   [${s}]`];let i=!1;if(!t.object.objectId)return o.push("      (no properties)"),{scopeName:s,lines:o,hasTruncatedValues:!1};try{const e=(await n.send("Runtime.getProperties",{objectId:t.object.objectId,ownProperties:!0,generatePreview:!0})).result||[],s=e.slice(0,a.maxPropertiesPerScope),r=e.length>a.maxPropertiesPerScope;for(const e of s)if(e.value)if(a.useObjectPreviews&&e.value.preview){const n=formatPreview(e.value.preview),t=e.value.subtype||e.value.type;o.push(`      ${e.name}: (${t}) ${n}`),e.value.preview.overflow&&(i=!0)}else{const{formatted:n,truncated:t,type:s}=f(e.value,a.maxLineLength);i=i||t;const r=t?" [truncated]":"";o.push(`      ${e.name}: (${s}) ${n}${r}`)}else e.get&&o.push(`      ${e.name}: [getter]`);r&&(o.push(`      ... and ${e.length-a.maxPropertiesPerScope} more properties`),i=!0)}catch(n){const t=n instanceof Error?n.message:String(n);o.push(`      (unable to retrieve properties: ${t})`),e(`[debugger] Failed to retrieve properties for scope ${s}: ${n}`)}return{scopeName:s,lines:o,hasTruncatedValues:i}}),r=await Promise.all(i);for(const e of r)s.push(...e.lines),o=o||e.hasTruncatedValues;return{lines:s,hasTruncatedValues:o}}export const setBreakpoint=m({name:"set_breakpoint",description:"Set a JavaScript breakpoint at a specific line in a file matching a URL pattern. Supports smart snapping for minified code.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("A unique identifier for this breakpoint (used to remove it later)."),urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to set the breakpoint at (1-based, as shown in editors)."),columnNumber:n.number().int().nonnegative().optional().describe("Optional target column number (0-based) for smart snapping. When specified, the tool will find the nearest valid breakpoint position within snapRange of this column."),snapRange:n.number().int().positive().optional().describe("Search range around the target column for finding valid breakpoint positions. Defaults to 100."),condition:n.string().optional().describe("Optional JavaScript expression. The breakpoint only triggers when this evaluates to true.")},handler:async(e,n,t)=>{const{breakpointId:a,urlRegex:s,lineNumber:o,columnNumber:u,snapRange:m=100,condition:g}=e.params,b=t.getSelectedPage(),f=await r(b),h=i(b);if(void 0!==u&&u<0)return n.appendResponseLine(`‚ùå Invalid column number: ${u}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid column positions"),void n.appendResponseLine("   ‚Ä¢ Column 0 represents the start of the line");const v=o-1,L=u??0;let R=L,$=!1;if(void 0!==u){const e=await p(f,s);if(0===e.length)return n.appendResponseLine(`‚ùå Failed to set breakpoint: No scripts found matching pattern "${s}"`),n.appendResponseLine(`   Requested position: line ${o}, column ${u}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded in the page"),n.appendResponseLine("   ‚Ä¢ Check that the URL pattern is correct (use regex syntax)"),void n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations");const t=Math.max(0,L-m),a=L+m;let i=[];for(const n of e){const e=await c(f,n.scriptId,v,t,v,a,n.url);i=i.concat(e)}if(0===i.length)return n.appendResponseLine("‚ùå Failed to set breakpoint: No valid breakpoint positions found"),n.appendResponseLine(`   Requested position: line ${o}, column ${u}`),n.appendResponseLine(`   Search range: columns ${t} - ${a}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations on this line"),n.appendResponseLine(`   ‚Ä¢ Try increasing snapRange (currently ${m}) to search a wider area`),void n.appendResponseLine("   ‚Ä¢ Verify the line number contains executable code");const r=l(i,L);r&&(R=r.columnNumber,$=R!==L)}const y={lineNumber:v,urlRegex:s,columnNumber:R};g&&(y.condition=g);try{const e=await f.send("Debugger.setBreakpointByUrl",y),t=e.locations;if(t&&t.length>0){const i=t[0],r=i.lineNumber+1,p=i.columnNumber,l=$||r!==o||p!==R,c={breakpointId:e.breakpointId,urlPattern:s,lineNumber:o,columnNumber:u,resolvedLineNumber:r,resolvedColumnNumber:p,condition:g,wasSnapped:l};h.breakpoints.set(a,c),n.appendResponseLine(`‚úÖ Breakpoint "${a}" set successfully`),l&&n.appendResponseLine("‚ö° Snapped to nearest valid position"),n.appendResponseLine(`   URL pattern: ${s}`),void 0!==u?(n.appendResponseLine(`   Requested: line ${o}, column ${u}`),n.appendResponseLine(`   Resolved:  line ${r}, column ${p}`)):(n.appendResponseLine(`   Line: ${o}`),r!==o&&n.appendResponseLine(`   Resolved line: ${r}`)),g&&n.appendResponseLine(`   Condition: ${g}`),n.appendResponseLine(`   CDP breakpoint ID: ${e.breakpointId}`),n.appendResponseLine(""),n.appendResponseLine("üìç Resolved locations:");for(const e of t){const t=d(f).get(e.scriptId),a=t?.url||`Script ${e.scriptId}`;n.appendResponseLine(`   ${a}:${e.lineNumber+1}:${e.columnNumber}`)}}else await f.send("Debugger.removeBreakpoint",{breakpointId:e.breakpointId}),n.appendResponseLine("‚ùå Failed to set breakpoint: No matching scripts found"),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${o}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the URL pattern matches a loaded script"),n.appendResponseLine("   ‚Ä¢ Check that the line number contains executable code"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations")}catch(e){n.appendResponseLine(`‚ùå Failed to set breakpoint: ${e instanceof Error?e.message:String(e)}`),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${o}`),void 0!==u&&n.appendResponseLine(`   Column: ${u}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded and the URL pattern is correct")}}});export const removeBreakpoint=m({name:"remove_breakpoint",description:"Remove a previously set JavaScript breakpoint by its ID.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("The ID of the breakpoint to remove (as specified when setting it).")},handler:async(e,n,a)=>{const{breakpointId:s}=e.params,o=a.getSelectedPage(),r=i(o),p=r.breakpoints.get(s);if(!p)return void n.appendResponseLine(`‚ö†Ô∏è Breakpoint "${s}" not found.`);const l=await t(o);try{await l.send("Debugger.removeBreakpoint",{breakpointId:p.breakpointId}),r.breakpoints.delete(s),n.appendResponseLine(`‚úÖ Removed breakpoint "${s}"`)}catch(e){n.appendResponseLine(`‚ùå Failed to remove breakpoint: ${e instanceof Error?e.message:String(e)}`)}}});export const listBreakpoints=m({name:"list_breakpoints",description:"List all active JavaScript breakpoints on the current page. Supports pagination and search.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{searchTerm:n.string().optional().describe("Search term to filter breakpoints by ID or URL pattern (case-insensitive)."),pageSize:n.number().int().positive().optional().describe("Maximum number of breakpoints to return per page."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,n,t)=>{const{searchTerm:a,pageSize:o,pageIdx:r}=e.params,p=t.getSelectedPage(),l=i(p);if(0===l.breakpoints.size)return void n.appendResponseLine("No active breakpoints.");let c=Array.from(l.breakpoints.entries());if(a){const e=a.toLowerCase();if(c=c.filter(([n,t])=>n.toLowerCase().includes(e)||t.urlPattern.toLowerCase().includes(e)),0===c.length)return void n.appendResponseLine(`No breakpoints matching "${a}" found.`)}const d=s(c,{pageSize:o,pageIdx:r});n.appendResponseLine(`Active breakpoints (${c.length} total):`),d.totalPages>1&&(n.appendResponseLine(`Showing ${d.startIndex+1}-${d.endIndex} (Page ${d.currentPage+1} of ${d.totalPages})`),d.hasNextPage&&n.appendResponseLine(`Next page: pageIdx=${d.currentPage+1}`)),n.appendResponseLine("");for(const[e,t]of d.items)n.appendResponseLine(`üìç ${e}`),n.appendResponseLine(`   URL pattern: ${t.urlPattern}`),n.appendResponseLine(`   Line: ${t.lineNumber}`),void 0!==t.columnNumber&&n.appendResponseLine(`   Column: ${t.columnNumber}`),t.condition&&n.appendResponseLine(`   Condition: ${t.condition}`),n.appendResponseLine("")}});export const clearAllBreakpoints=m({name:"clear_all_breakpoints",description:"Remove all active JavaScript breakpoints on the current page.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),o=i(s),r=await t(s),p=o.breakpoints.size,l=[];for(const[e,n]of o.breakpoints)try{await r.send("Debugger.removeBreakpoint",{breakpointId:n.breakpointId})}catch(n){l.push(`${e}: ${n instanceof Error?n.message:String(n)}`)}if(o.breakpoints.clear(),l.length>0){n.appendResponseLine(`‚ö†Ô∏è Cleared ${p-l.length}/${p} breakpoints.`),n.appendResponseLine("Errors:");for(const e of l)n.appendResponseLine(`   ${e}`)}else n.appendResponseLine(`‚úÖ Cleared ${p} breakpoint(s).`)}});export const resumeExecution=m({name:"resume_execution",description:"Resume JavaScript execution after hitting a breakpoint.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),o=i(s);if(!o.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const r=await t(s);try{await r.send("Debugger.resume"),o.isPaused=!1,o.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Execution resumed.")}catch(e){n.appendResponseLine(`‚ùå Failed to resume: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOver=m({name:"step_over",description:"Step over to the next line of code without stepping into function calls.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!i(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.stepOver"),n.appendResponseLine("‚úÖ Stepped over to next line.")}catch(e){n.appendResponseLine(`‚ùå Failed to step over: ${e instanceof Error?e.message:String(e)}`)}}});export const stepInto=m({name:"step_into",description:"Step into a function call at the current line.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!i(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.stepInto"),n.appendResponseLine("‚úÖ Stepped into function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step into: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOut=m({name:"step_out",description:"Step out of the current function to return to the caller.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!i(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.stepOut"),n.appendResponseLine("‚úÖ Stepped out of function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step out: ${e instanceof Error?e.message:String(e)}`)}}});export const getDebuggerStatus=m({name:"get_debugger_status",description:"Get the current status of the JavaScript debugger including call stack, code context, and scope variables.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).optional().describe("The call frame index to show variables for (0 = current frame). Default is 0."),contextLines:n.number().int().nonnegative().default(5).optional().describe("Number of lines to show before and after the current line. Set to 0 to disable code context. Default is 5."),maxPropertiesPerScope:n.number().int().positive().optional().describe("Maximum number of properties to show per scope. Default is 10."),skipScopeVariables:n.boolean().optional().describe("Skip scope variable inspection entirely for faster execution. Default is false."),useObjectPreviews:n.boolean().optional().describe("Use object preview data instead of fetching full properties. Default is true."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated."),maxCallStackFrames:n.number().int().positive().default(20).optional().describe("Maximum number of call stack frames to display. Default is 20."),maxLineLength:n.number().int().positive().default(500).optional().describe("Maximum length of a single code line or variable value. Default is 500.")},handler:async(n,s,o)=>{const r=o.getSelectedPage(),p=i(r),l=n.params.frameIndex??0,c=n.params.contextLines??5,d=n.params.maxOutputLines??100,m=n.params.maxCallStackFrames??20,f=n.params.maxLineLength??500,h=a().maxBodySize,v={maxPropertiesPerScope:n.params.maxPropertiesPerScope??a().debugger.maxPropertiesPerScope,skipScopeVariables:n.params.skipScopeVariables??a().debugger.skipScopeVariables,useObjectPreviews:n.params.useObjectPreviews??a().debugger.useObjectPreviews,maxObjectDepth:a().debugger.maxObjectDepth,maxLineLength:f},L=[];let R=!1,$=0;const y=e=>{if(R)return!1;if(L.length>=d||$>=h)return R=!0,!1;let n=e;return e.length>f&&(n=e.substring(0,f)+"... [line truncated]"),$+n.length>h&&(n=n.substring(0,h-$)+"... [total size truncated]",R=!0),L.push(n),$+=n.length+1,!R},x=e=>{for(const n of e)if(!y(n))return!1;return!0};if(y("üîç Debugger Status:"),y("   Enabled: "+(p.enabled?"Yes":"No")),y("   Paused: "+(p.isPaused?"Yes":"No")),y(`   Active breakpoints: ${p.breakpoints.size}`),p.isPaused&&p.pausedCallFrames){if(l>=p.pausedCallFrames.length){y(""),y(`‚ùå Invalid frame index: ${l}`),y("   Valid range: 0-"+(p.pausedCallFrames.length-1));for(const e of L)s.appendResponseLine(e);return}y(""),y("üìö Call Stack:");const n=p.pausedCallFrames.length,a=Math.min(n,m),o=n>m;for(let e=0;e<a&&!R;e++){const n=p.pausedCallFrames[e],t=e===l?" ‚ñ∂":"";y(`   ${e}: ${n.functionName} at ${n.url||"(unknown)"}:${n.location.lineNumber+1}:${n.location.columnNumber??0}${t}`)}o&&!R&&y(`   ... and ${n-m} more frames`);const i=p.pausedCallFrames[l],d=await t(r);if(c>0&&!R){y("");try{const e=await u(d,i.location.scriptId);if(null===e)y(`‚ö†Ô∏è Source unavailable for script ${i.location.scriptId}`),y("   The script source could not be retrieved from the browser.");else{const n=g(e,{lineNumber:i.location.lineNumber+1,columnNumber:i.location.columnNumber??0,contextLines:c,formatMinified:!1,maxLineLength:f}),t=b(n,i.location.lineNumber+1,i.location.columnNumber??0,i.url,i.functionName);x(t.split("\n"))}}catch(n){const t=n instanceof Error?n.message:String(n);y(`‚ö†Ô∏è Failed to retrieve code context: ${t}`),e(`[debugger] Error retrieving code context for script ${i.location.scriptId}: ${n}`)}}if(!R){y(""),y(`üì¶ Scope Variables (frame ${l}: ${i.functionName}):`);try{const{lines:e,hasTruncatedValues:n}=await inspectScopeVariablesOptimized(d,i.scopeChain,v);x(e),n&&!R&&(y(""),y("‚ÑπÔ∏è  Some values are truncated. Use get_scope_variables for full details or save_scope_variables to save to file."))}catch(n){const t=n instanceof Error?n.message:String(n);y(`   ‚ö†Ô∏è Failed to inspect scope variables: ${t}`),y("   Use get_scope_variables for detailed inspection."),e(`[debugger] Error inspecting scope variables: ${n}`)}}}for(const e of L)s.appendResponseLine(e);R&&(s.appendResponseLine(""),s.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${d} lines.`),s.appendResponseLine("   Use get_scope_variables for detailed variable inspection."),s.appendResponseLine(`   Increase maxOutputLines parameter to see more (current: ${d}).`))}});export const evaluateOnCallFrame=m({name:"evaluate_on_call_frame",description:"Evaluate a JavaScript expression in the context of a specific call frame when paused.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{expression:n.string().describe("The JavaScript expression to evaluate."),frameIndex:n.number().int().nonnegative().default(0).describe("The index of the call frame to evaluate in (0 = current frame).")},handler:async(e,n,a)=>{const{expression:s,frameIndex:o}=e.params,r=a.getSelectedPage(),p=i(r);if(!p.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!p.pausedCallFrames||o>=p.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((p.pausedCallFrames?.length??1)-1));const l=p.pausedCallFrames[o],c=await t(r);try{const e=await c.send("Debugger.evaluateOnCallFrame",{callFrameId:l.callFrameId,expression:s,returnByValue:!0});e.exceptionDetails?(n.appendResponseLine("‚ùå Evaluation error:"),n.appendResponseLine(`   ${e.exceptionDetails.exception?.description||e.exceptionDetails.text}`)):(n.appendResponseLine(`‚úÖ Result (frame ${o}: ${l.functionName}):`),n.appendResponseLine("```json"),n.appendResponseLine(JSON.stringify(e.result?.value??e.result,null,2)),n.appendResponseLine("```"))}catch(e){n.appendResponseLine(`‚ùå Failed to evaluate: ${e instanceof Error?e.message:String(e)}`)}}});export const getScopeVariables=m({name:"get_scope_variables",description:"Get detailed variable information from a specific scope when paused at a breakpoint. Supports pagination and search.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),scopeType:n.enum(["local","closure","block","script","global","catch","with","module","wasm-expression-stack"]).optional().describe("Filter to a specific scope type. If omitted, shows all scopes."),variableName:n.string().optional().describe("Specific variable name to inspect in detail. If omitted, shows all variables."),searchTerm:n.string().optional().describe("Search term to filter variable names (case-insensitive substring match)."),pageSize:n.number().int().positive().optional().describe("Maximum number of variables to return per page. When omitted, uses default page size."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based). When omitted, returns the first page."),maxDepth:n.number().int().positive().default(3).optional().describe("Maximum depth for nested object inspection. Default is 3."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated with a hint to use saveToFile."),saveToFile:n.string().optional().describe("Optional file path to save full output. When provided, saves complete output to file without truncation."),maxLineLength:n.number().int().positive().default(1e3).optional().describe("Maximum length of a single variable value or output line. Default is 1000.")},handler:async(e,n,o)=>{const{frameIndex:r,scopeType:p,variableName:l,searchTerm:c,pageSize:d,pageIdx:u,maxDepth:m,maxOutputLines:g,saveToFile:b,maxLineLength:h=1e3}=e.params,v=o.getSelectedPage(),L=i(v),R=a().maxBodySize;if(!L.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!L.pausedCallFrames||r>=L.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((L.pausedCallFrames?.length??1)-1));const $=L.pausedCallFrames[r],y=await t(v),x=[],S=g??100;let w=0;const k=e=>{x.push(e),w+=e.length+1};async function I(e,n,t){const a=[];if(n<=0)return a.push(`${t}[max depth reached]`),a;try{const s=(await y.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;if("object"===s.type&&s.objectId&&"null"!==s.subtype){a.push(`${t}${e.name}: (${s.subtype||s.type}) ${s.description||""}`);const o=await I(s.objectId,n-1,t+"  ");a.push(...o)}else{const{formatted:n,type:o}=f(s,h);a.push(`${t}${e.name}: (${o}) ${n}`)}}else e.get&&a.push(`${t}${e.name}: [getter]`)}catch(e){const n=e instanceof Error?e.message:String(e);a.push(`${t}(unable to retrieve properties: ${n})`)}return a}k(`üì¶ Scope Variables (frame ${r}: ${$.functionName}):`),k("");for(const e of $.scopeChain){if(p&&e.type!==p)continue;if(k(`=== [${e.name?`${e.type}: ${e.name}`:e.type}] ===`),e.object.objectId){try{let n=(await y.send("Runtime.getProperties",{objectId:e.object.objectId,ownProperties:!0,generatePreview:!0})).result||[];if(l){const e=n.find(e=>e.name===l);if(e){if(k(`Variable: ${l}`),e.value){const n=e.value;if("object"===n.type&&n.objectId&&"null"!==n.subtype){k(`Type: ${n.subtype||n.type}`),k(`Description: ${n.description||"N/A"}`),k("Properties:");const e=await I(n.objectId,m??3,"   ");for(const n of e)k(n)}else{const{formatted:e,type:t}=f(n,h);k(`Type: ${t}`),k(`Value: ${e}`)}}}else k(`   Variable "${l}" not found in this scope.`)}else{if(c){const e=c.toLowerCase();if(n=n.filter(n=>n.name.toLowerCase().includes(e)),0===n.length){k(`   No variables matching "${c}" found.`),k("");continue}}const e=s(n,{pageSize:d,pageIdx:u});e.totalPages>1&&(k(`Showing ${e.startIndex+1}-${e.endIndex} of ${n.length} variables (Page ${e.currentPage+1} of ${e.totalPages})`),e.hasNextPage&&k(`Next page: pageIdx=${e.currentPage+1}`),e.hasPreviousPage&&k("Previous page: pageIdx="+(e.currentPage-1)));for(const n of e.items)if(n.value){const e=n.value;if("object"===e.type&&e.objectId&&"null"!==e.subtype){k(`${n.name}: (${e.subtype||e.type}) ${e.description||""}`);const t=await I(e.objectId,(m??3)-1,"   ");for(const e of t)k(e)}else{const{formatted:t,type:a}=f(e,h);k(`${n.name}: (${a}) ${t}`)}}else n.get&&k(`${n.name}: [getter]`)}}catch(e){k(`   (error retrieving properties: ${e instanceof Error?e.message:String(e)})`)}if(k(""),w>=R&&!b)break}else k("   (no properties)"),k("")}if(b){const e=x.join("\n");await o.saveFile((new TextEncoder).encode(e),b),n.appendResponseLine(`‚úÖ Full output saved to ${b} (${x.length} lines)`),n.appendResponseLine("")}let P=0,N=!1;for(let e=0;e<x.length;e++){const t=x[e];if(e>=S||P+t.length>R){N=!0;break}let a=t;t.length>h&&(a=t.substring(0,h)+"... [line truncated]"),n.appendResponseLine(a),P+=a.length+1}N&&(n.appendResponseLine(""),n.appendResponseLine("‚ö†Ô∏è Output truncated: showing first part of the result."),n.appendResponseLine("   Use saveToFile parameter to save full output, or increase maxOutputLines/maxLineLength."),b||n.appendResponseLine('   Example: get_scope_variables({ saveToFile: "/tmp/scope_vars.txt" })'))}});export const saveScopeVariables=m({name:"save_scope_variables",description:"Save all scope variables from the current debug context to a JSON file.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{filePath:n.string().describe("Absolute or relative file path to save the scope variables JSON."),frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),maxDepth:n.number().int().positive().default(5).optional().describe("Maximum depth for nested object serialization. Default is 5."),includeGlobal:n.boolean().default(!1).optional().describe("Include global scope variables. Default is false (globals are very large).")},handler:async(e,n,a)=>{const{filePath:s,frameIndex:o,maxDepth:r,includeGlobal:p}=e.params,l=a.getSelectedPage(),c=i(l);if(!c.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!c.pausedCallFrames||o>=c.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((c.pausedCallFrames?.length??1)-1));const d=c.pausedCallFrames[o],u=await t(l);async function m(e,n,t){if(n<=0||t.has(e))return"[max depth or circular reference]";t.add(e);const a={};try{const s=(await u.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;"object"===s.type&&s.objectId&&"null"!==s.subtype?(s.subtype,a[e.name]=await m(s.objectId,n-1,t)):void 0!==s.value?a[e.name]=s.value:s.unserializableValue?a[e.name]=`[${s.unserializableValue}]`:a[e.name]=`[${s.subtype||s.type}]`}else e.get&&(a[e.name]="[getter]")}catch{return"[error serializing]"}return a}const g={frame:{index:o,functionName:d.functionName,url:d.url,location:{lineNumber:d.location.lineNumber+1,columnNumber:d.location.columnNumber??0}},scopes:{}};for(const e of d.scopeChain){if("global"===e.type&&!p){g.scopes[e.type]="[skipped - use includeGlobal:true to include]";continue}const n=e.name?`${e.type}:${e.name}`:e.type;e.object.objectId?g.scopes[n]=await m(e.object.objectId,r??5,new Set):g.scopes[n]={}}const b=JSON.stringify(g,null,2);await a.saveFile((new TextEncoder).encode(b),s),n.appendResponseLine(`‚úÖ Saved scope variables to ${s}`),n.appendResponseLine(`   Frame: ${d.functionName}`),n.appendResponseLine(`   Scopes saved: ${Object.keys(g.scopes).join(", ")}`)}});export const pauseOnExceptions=m({name:"pause_on_exceptions",description:"Configure whether the debugger should pause on exceptions (none, uncaught, or all).",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{state:n.enum(["none","uncaught","all"]).describe("When to pause on exceptions.")},handler:async(e,n,t)=>{const{state:a}=e.params,s=t.getSelectedPage(),o=await r(s);try{switch(await o.send("Debugger.setPauseOnExceptions",{state:a}),n.appendResponseLine(`‚úÖ Exception pausing set to: ${a}`),a){case"none":n.appendResponseLine("   Debugger will not pause on any exceptions.");break;case"uncaught":n.appendResponseLine("   Debugger will pause only on uncaught exceptions.");break;case"all":n.appendResponseLine("   Debugger will pause on all exceptions (caught and uncaught).")}}catch(e){n.appendResponseLine(`‚ùå Failed to set exception pausing: ${e instanceof Error?e.message:String(e)}`)}}});export const disableDebugger=m({name:"disable_debugger",description:"Disable the JavaScript debugger on the current page and remove all breakpoints.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),o=i(s);if(!o.enabled)return void n.appendResponseLine("‚ÑπÔ∏è Debugger is already disabled.");const r=await t(s);try{await r.send("Debugger.disable"),o.enabled=!1,o.breakpoints.clear(),o.isPaused=!1,o.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Debugger disabled."),n.appendResponseLine("   All breakpoints have been removed.")}catch(e){n.appendResponseLine(`‚ùå Failed to disable debugger: ${e instanceof Error?e.message:String(e)}`)}}});export const getPossibleBreakpoints=m({name:"get_possible_breakpoints",description:"Discover all valid breakpoint locations in a script at a specific line. Useful for minified code.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to search for breakpoints (1-based, as shown in editors)."),startColumn:n.number().int().nonnegative().optional().describe("Optional start column to filter results (0-based). Defaults to 0."),endColumn:n.number().int().nonnegative().optional().describe("Optional end column to filter results (0-based). Defaults to end of line."),maxCount:n.number().int().positive().optional().describe("Maximum number of locations to return. Defaults to 20.")},handler:async(e,n,t)=>{const{urlRegex:a,lineNumber:s,startColumn:o,endColumn:i,maxCount:l=20}=e.params,d=t.getSelectedPage(),u=await r(d);if(void 0!==o&&o<0)return n.appendResponseLine(`‚ùå Invalid startColumn: ${o}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Use startColumn=0 to search from the beginning of the line.");if(void 0!==i&&i<0)return n.appendResponseLine(`‚ùå Invalid endColumn: ${i}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Omit endColumn to search to the end of the line.");if(void 0!==o&&void 0!==i&&o>i)return n.appendResponseLine(`‚ùå Invalid column range: startColumn (${o}) > endColumn (${i})`),n.appendResponseLine("   startColumn must be less than or equal to endColumn."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Swap the values or adjust the range.");const m=s-1,g=await p(u,a);if(0===g.length)return n.appendResponseLine(`‚ùå No scripts found matching pattern: ${a}`),void n.appendResponseLine("   üí° Suggestion: Verify the script is loaded and the URL pattern is correct.");let b=[];for(const e of g){const n=o??0,t=i??n+100,a=(await c(u,e.scriptId,m,n,m,t,e.url)).filter(e=>!(void 0!==o&&e.columnNumber<o)&&!(void 0!==i&&e.columnNumber>i));b=b.concat(a)}if(0===b.length)return n.appendResponseLine(`‚ùå No valid breakpoint locations found at line ${s}`),void 0===o&&void 0===i||n.appendResponseLine(`   Column range: ${o??0} - ${i??"end"}`),void n.appendResponseLine("   üí° Suggestion: Try a different line or expand the column range.");b.sort((e,n)=>{const t=e.scriptUrl.localeCompare(n.scriptUrl);return 0!==t?t:e.columnNumber-n.columnNumber});const f=b.length,h=f>l,v=h?b.slice(0,l):b;n.appendResponseLine(`üìç Possible breakpoint locations at line ${s}:`),n.appendResponseLine(`   URL pattern: ${a}`),void 0===o&&void 0===i||n.appendResponseLine(`   Column range: ${o??0} - ${i??"end"}`),n.appendResponseLine("");for(const e of v)n.appendResponseLine(`   ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`);h?(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Results truncated: showing ${l} of ${f} locations`),n.appendResponseLine("   üí° Suggestion: Use startColumn/endColumn to narrow the search range.")):(n.appendResponseLine(""),n.appendResponseLine(`Found ${f} valid breakpoint location(s).`))}});export async function ensureDebuggerEnabledForPage(e){await r(e)}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as n}from"../third_party/index.js";import{getCdpSession as t}from"../utils/cdp.js";import{getConfig as a}from"../utils/config.js";import{paginate as s}from"../utils/pagination.js";import{clearParseResultCache as o}from"./analysis.js";import{ToolCategory as i}from"./categories.js";import{findMatchingScripts as r,findNearestBreakpointLocation as p,queryPossibleBreakpoints as c,cacheScript as l,clearScriptCache as u,getScriptCache as d,getScriptSource as m}from"../utils/smartBreakpointUtils.js";import{ScriptCacheRegistry as g}from"../utils/scriptCacheRegistry.js";import{defineTool as b}from"./ToolDefinition.js";import{extractContextCode as f,formatContextCodeOutput as h}from"../utils/contextCodeUtils.js";function v(e,n=a().maxInlineStringLength){const t=e.type||"unknown",s=e.subtype;if(void 0!==e.value){const s=function(e,n=a().maxInlineStringLength){if(void 0===e)return{formatted:"undefined",truncated:!1};if(null===e)return{formatted:"null",truncated:!1};let t;if("string"==typeof e)t=JSON.stringify(e);else if("object"==typeof e)try{t=JSON.stringify(e)}catch{t=String(e)}else t=String(e);return t.length>n?{formatted:t.substring(0,n)+"...",truncated:!0}:{formatted:t,truncated:!1}}(e.value,n);return{...s,type:t}}if(e.unserializableValue)return{formatted:e.unserializableValue,truncated:!1,type:t};if(e.preview){const a=e.preview;if(a.overflow){return{formatted:`{${(a.properties||[]).slice(0,5).map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}, ...}`,truncated:!0,type:s||t}}if(a.properties){const e=`{${a.properties.map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}}`;return e.length>n?{formatted:e.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:e,truncated:!1,type:s||t}}}if(e.description){const a=e.description;return a.length>n?{formatted:a.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:a,truncated:!1,type:s||t}}return{formatted:`[${s||t}]`,truncated:!1,type:s||t}}export function formatPreview(e){if(!e)return"[no preview]";if("object"===e.type){const n=e.properties||[];if(0===n.length)return"array"===e.subtype?"[]":"{}";const t=n.slice(0,3).map(e=>`${e.name}: ${e.value??e.type}`).join(", ");return"array"===e.subtype?e.overflow?`[${t}, ...]`:`[${t}]`:e.overflow?`{${t}, ...}`:`{${t}}`}return e.description||String(e.value??"[unknown]")}export async function inspectScopeVariablesOptimized(n,t,a){const s=[];let o=!1;if(a.skipScopeVariables)return s.push("   [Scope inspection skipped - use get_scope_variables for details]"),{lines:s,hasTruncatedValues:!1};const i=t.map(async t=>{if("global"===t.type)return{scopeName:"global",lines:["   [global] (use get_scope_variables to inspect)"],hasTruncatedValues:!1};const s=t.name?`${t.type}: ${t.name}`:t.type,o=[`   [${s}]`];let i=!1;if(!t.object.objectId)return o.push("      (no properties)"),{scopeName:s,lines:o,hasTruncatedValues:!1};try{const e=(await n.send("Runtime.getProperties",{objectId:t.object.objectId,ownProperties:!0,generatePreview:!0})).result||[],s=e.slice(0,a.maxPropertiesPerScope),r=e.length>a.maxPropertiesPerScope;for(const e of s)if(e.value)if(a.useObjectPreviews&&e.value.preview){const n=formatPreview(e.value.preview),t=e.value.subtype||e.value.type;o.push(`      ${e.name}: (${t}) ${n}`),e.value.preview.overflow&&(i=!0)}else{const{formatted:n,truncated:t,type:a}=v(e.value);i=i||t;const s=t?" [truncated]":"";o.push(`      ${e.name}: (${a}) ${n}${s}`)}else e.get&&o.push(`      ${e.name}: [getter]`);r&&(o.push(`      ... and ${e.length-a.maxPropertiesPerScope} more properties`),i=!0)}catch(n){const t=n instanceof Error?n.message:String(n);o.push(`      (unable to retrieve properties: ${t})`),e(`[debugger] Failed to retrieve properties for scope ${s}: ${n}`)}return{scopeName:s,lines:o,hasTruncatedValues:i}}),r=await Promise.all(i);for(const e of r)s.push(...e.lines),o=o||e.hasTruncatedValues;return{lines:s,hasTruncatedValues:o}}const R=new WeakMap;function L(e){let n=R.get(e);return n||(n={enabled:!1,breakpoints:new Map,isPaused:!1},R.set(e,n)),n}const y=new WeakSet;async function $(n){const a=await t(n),s=L(n);if(s.enabled||(await a.send("Debugger.enable"),s.enabled=!0,a.on("Debugger.scriptParsed",async n=>{const t=n.scriptId,s=n.url||"";if(l(a,{scriptId:t,url:s,startLine:n.startLine,startColumn:n.startColumn,endLine:n.endLine,endColumn:n.endColumn}),s)try{const e=(await a.send("Debugger.getScriptSource",{scriptId:t})).scriptSource;if(e){const n=g.getOrCreate(a);await n.cacheScript(t,s,e)}}catch(n){e(`[debugger] Failed to cache script source for ${t}: ${n}`)}e(`[debugger] Script parsed: ${s||t}`)}),a.on("Debugger.paused",n=>{s.isPaused=!0,s.pausedCallFrames=n.callFrames?.map(e=>({callFrameId:e.callFrameId,functionName:e.functionName||"(anonymous)",location:{scriptId:e.location.scriptId,lineNumber:e.location.lineNumber,columnNumber:e.location.columnNumber},url:e.url||"",scopeChain:e.scopeChain?.map(e=>({type:e.type,object:{type:e.object?.type,objectId:e.object?.objectId},name:e.name}))||[]})),e("[debugger] Execution paused at breakpoint")}),a.on("Debugger.resumed",()=>{s.isPaused=!1,s.pausedCallFrames=void 0,e("[debugger] Execution resumed")})),!y.has(n)){let t;y.add(n);try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}a.on("Page.frameStartedLoading",async i=>{let r=!t||i.frameId===t;if(!r)try{const e=await a.send("Page.getFrameTree"),n=e.frameTree?.frame?.id;i.frameId===n&&(r=!0,t=n)}catch{r=!0}if(r){if(u(a),o(a),e("[debugger] Script cache and parse result cache cleared on navigation"),s.breakpoints.size>0){e("[debugger] Main frame started loading, restoring breakpoints immediately...");try{await async function(n,t){const a=L(n);try{await t.send("Emulation.setScriptExecutionDisabled",{value:!0}),e("[debugger] Script execution disabled temporarily")}catch{}try{await t.send("Debugger.enable")}catch{}for(const[n,s]of a.breakpoints)try{const a={lineNumber:s.resolvedLineNumber-1,urlRegex:s.urlPattern,columnNumber:s.resolvedColumnNumber};s.condition&&(a.condition=s.condition);const o=await t.send("Debugger.setBreakpointByUrl",a);s.breakpointId=o.breakpointId,e(`[debugger] Restored breakpoint "${n}" after navigation`)}catch(t){e(`[debugger] Failed to restore breakpoint "${n}": ${t}`)}try{await t.send("Emulation.setScriptExecutionDisabled",{value:!1}),e("[debugger] Script execution re-enabled")}catch{}}(n,a)}catch(n){e(`[debugger] Error restoring breakpoints: ${n}`)}}try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}}});try{await a.send("Page.enable")}catch{}}return a}export const setBreakpoint=b({name:"set_breakpoint",description:"Set a JavaScript breakpoint at a specific line in a file matching a URL pattern. Supports smart snapping for minified code.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("A unique identifier for this breakpoint (used to remove it later)."),urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to set the breakpoint at (1-based, as shown in editors)."),columnNumber:n.number().int().nonnegative().optional().describe("Optional target column number (0-based) for smart snapping. When specified, the tool will find the nearest valid breakpoint position within snapRange of this column."),snapRange:n.number().int().positive().optional().describe("Search range around the target column for finding valid breakpoint positions. Defaults to 100."),condition:n.string().optional().describe("Optional JavaScript expression. The breakpoint only triggers when this evaluates to true.")},handler:async(e,n,t)=>{const{breakpointId:a,urlRegex:s,lineNumber:o,columnNumber:i,snapRange:l=100,condition:u}=e.params,m=t.getSelectedPage(),g=await $(m),b=L(m);if(void 0!==i&&i<0)return n.appendResponseLine(`‚ùå Invalid column number: ${i}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid column positions"),void n.appendResponseLine("   ‚Ä¢ Column 0 represents the start of the line");const f=o-1,h=i??0;let v=h,R=!1;if(void 0!==i){const e=await r(g,s);if(0===e.length)return n.appendResponseLine(`‚ùå Failed to set breakpoint: No scripts found matching pattern "${s}"`),n.appendResponseLine(`   Requested position: line ${o}, column ${i}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded in the page"),n.appendResponseLine("   ‚Ä¢ Check that the URL pattern is correct (use regex syntax)"),void n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations");const t=Math.max(0,h-l),a=h+l;let u=[];for(const n of e){const e=await c(g,n.scriptId,f,t,f,a,n.url);u=u.concat(e)}if(0===u.length)return n.appendResponseLine("‚ùå Failed to set breakpoint: No valid breakpoint positions found"),n.appendResponseLine(`   Requested position: line ${o}, column ${i}`),n.appendResponseLine(`   Search range: columns ${t} - ${a}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations on this line"),n.appendResponseLine(`   ‚Ä¢ Try increasing snapRange (currently ${l}) to search a wider area`),void n.appendResponseLine("   ‚Ä¢ Verify the line number contains executable code");const d=p(u,h);d&&(v=d.columnNumber,R=v!==h)}const y={lineNumber:f,urlRegex:s,columnNumber:v};u&&(y.condition=u);try{const e=await g.send("Debugger.setBreakpointByUrl",y),t=e.locations;if(t&&t.length>0){const r=t[0],p=r.lineNumber+1,c=r.columnNumber,l=R||p!==o||c!==v,m={breakpointId:e.breakpointId,urlPattern:s,lineNumber:o,columnNumber:i,resolvedLineNumber:p,resolvedColumnNumber:c,condition:u,wasSnapped:l};b.breakpoints.set(a,m),n.appendResponseLine(`‚úÖ Breakpoint "${a}" set successfully`),l&&n.appendResponseLine("‚ö° Snapped to nearest valid position"),n.appendResponseLine(`   URL pattern: ${s}`),void 0!==i?(n.appendResponseLine(`   Requested: line ${o}, column ${i}`),n.appendResponseLine(`   Resolved:  line ${p}, column ${c}`)):(n.appendResponseLine(`   Line: ${o}`),p!==o&&n.appendResponseLine(`   Resolved line: ${p}`)),u&&n.appendResponseLine(`   Condition: ${u}`),n.appendResponseLine(`   CDP breakpoint ID: ${e.breakpointId}`),n.appendResponseLine(""),n.appendResponseLine("üìç Resolved locations:");for(const e of t){const t=d(g).get(e.scriptId),a=t?.url||`Script ${e.scriptId}`;n.appendResponseLine(`   ${a}:${e.lineNumber+1}:${e.columnNumber}`)}}else await g.send("Debugger.removeBreakpoint",{breakpointId:e.breakpointId}),n.appendResponseLine("‚ùå Failed to set breakpoint: No matching scripts found"),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${o}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the URL pattern matches a loaded script"),n.appendResponseLine("   ‚Ä¢ Check that the line number contains executable code"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations")}catch(e){n.appendResponseLine(`‚ùå Failed to set breakpoint: ${e instanceof Error?e.message:String(e)}`),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${o}`),void 0!==i&&n.appendResponseLine(`   Column: ${i}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded and the URL pattern is correct")}}});export const removeBreakpoint=b({name:"remove_breakpoint",description:"Remove a previously set JavaScript breakpoint by its ID.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("The ID of the breakpoint to remove (as specified when setting it).")},handler:async(e,n,a)=>{const{breakpointId:s}=e.params,o=a.getSelectedPage(),i=L(o),r=i.breakpoints.get(s);if(!r)return void n.appendResponseLine(`‚ö†Ô∏è Breakpoint "${s}" not found.`);const p=await t(o);try{await p.send("Debugger.removeBreakpoint",{breakpointId:r.breakpointId}),i.breakpoints.delete(s),n.appendResponseLine(`‚úÖ Removed breakpoint "${s}"`)}catch(e){n.appendResponseLine(`‚ùå Failed to remove breakpoint: ${e instanceof Error?e.message:String(e)}`)}}});export const listBreakpoints=b({name:"list_breakpoints",description:"List all active JavaScript breakpoints on the current page. Supports pagination and search.",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{searchTerm:n.string().optional().describe("Search term to filter breakpoints by ID or URL pattern (case-insensitive)."),pageSize:n.number().int().positive().optional().describe("Maximum number of breakpoints to return per page."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,n,t)=>{const{searchTerm:a,pageSize:o,pageIdx:i}=e.params,r=L(t.getSelectedPage());if(0===r.breakpoints.size)return void n.appendResponseLine("No active breakpoints.");let p=Array.from(r.breakpoints.entries());if(a){const e=a.toLowerCase();if(p=p.filter(([n,t])=>n.toLowerCase().includes(e)||t.urlPattern.toLowerCase().includes(e)),0===p.length)return void n.appendResponseLine(`No breakpoints matching "${a}" found.`)}const c=s(p,{pageSize:o,pageIdx:i});n.appendResponseLine(`Active breakpoints (${p.length} total):`),c.totalPages>1&&(n.appendResponseLine(`Showing ${c.startIndex+1}-${c.endIndex} (Page ${c.currentPage+1} of ${c.totalPages})`),c.hasNextPage&&n.appendResponseLine(`Next page: pageIdx=${c.currentPage+1}`)),n.appendResponseLine("");for(const[e,t]of c.items)n.appendResponseLine(`üìç ${e}`),n.appendResponseLine(`   URL pattern: ${t.urlPattern}`),n.appendResponseLine(`   Line: ${t.lineNumber}`),void 0!==t.columnNumber&&n.appendResponseLine(`   Column: ${t.columnNumber}`),t.condition&&n.appendResponseLine(`   Condition: ${t.condition}`),n.appendResponseLine("")}});export const clearAllBreakpoints=b({name:"clear_all_breakpoints",description:"Remove all active JavaScript breakpoints on the current page.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),o=L(s),i=await t(s),r=o.breakpoints.size,p=[];for(const[e,n]of o.breakpoints)try{await i.send("Debugger.removeBreakpoint",{breakpointId:n.breakpointId})}catch(n){p.push(`${e}: ${n instanceof Error?n.message:String(n)}`)}if(o.breakpoints.clear(),p.length>0){n.appendResponseLine(`‚ö†Ô∏è Cleared ${r-p.length}/${r} breakpoints.`),n.appendResponseLine("Errors:");for(const e of p)n.appendResponseLine(`   ${e}`)}else n.appendResponseLine(`‚úÖ Cleared ${r} breakpoint(s).`)}});export const resumeExecution=b({name:"resume_execution",description:"Resume JavaScript execution after hitting a breakpoint.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),o=L(s);if(!o.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.resume"),o.isPaused=!1,o.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Execution resumed.")}catch(e){n.appendResponseLine(`‚ùå Failed to resume: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOver=b({name:"step_over",description:"Step over to the next line of code without stepping into function calls.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!L(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.stepOver"),n.appendResponseLine("‚úÖ Stepped over to next line.")}catch(e){n.appendResponseLine(`‚ùå Failed to step over: ${e instanceof Error?e.message:String(e)}`)}}});export const stepInto=b({name:"step_into",description:"Step into a function call at the current line.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!L(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.stepInto"),n.appendResponseLine("‚úÖ Stepped into function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step into: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOut=b({name:"step_out",description:"Step out of the current function to return to the caller.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!L(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.stepOut"),n.appendResponseLine("‚úÖ Stepped out of function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step out: ${e instanceof Error?e.message:String(e)}`)}}});export const getDebuggerStatus=b({name:"get_debugger_status",description:"Get the current status of the JavaScript debugger including call stack, code context, and scope variables.",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).optional().describe("The call frame index to show variables for (0 = current frame). Default is 0."),contextLines:n.number().int().nonnegative().default(5).optional().describe("Number of lines to show before and after the current line. Set to 0 to disable code context. Default is 5."),maxPropertiesPerScope:n.number().int().positive().optional().describe("Maximum number of properties to show per scope. Default is 10."),skipScopeVariables:n.boolean().optional().describe("Skip scope variable inspection entirely for faster execution. Default is false."),useObjectPreviews:n.boolean().optional().describe("Use object preview data instead of fetching full properties. Default is true."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated."),maxCallStackFrames:n.number().int().positive().default(20).optional().describe("Maximum number of call stack frames to display. Default is 20.")},handler:async(n,s,o)=>{const i=o.getSelectedPage(),r=L(i),p=n.params.frameIndex??0,c=n.params.contextLines??5,l=n.params.maxOutputLines??100,u=n.params.maxCallStackFrames??20,d={maxPropertiesPerScope:n.params.maxPropertiesPerScope??a().debugger.maxPropertiesPerScope,skipScopeVariables:n.params.skipScopeVariables??a().debugger.skipScopeVariables,useObjectPreviews:n.params.useObjectPreviews??a().debugger.useObjectPreviews,maxObjectDepth:a().debugger.maxObjectDepth},g=[];let b=!1;const v=e=>g.length>=l?(b=!0,!1):(g.push(e),!0),R=e=>{for(const n of e)if(!v(n))return!1;return!0};if(v("üîç Debugger Status:"),v("   Enabled: "+(r.enabled?"Yes":"No")),v("   Paused: "+(r.isPaused?"Yes":"No")),v(`   Active breakpoints: ${r.breakpoints.size}`),r.isPaused&&r.pausedCallFrames){if(p>=r.pausedCallFrames.length){v(""),v(`‚ùå Invalid frame index: ${p}`),v("   Valid range: 0-"+(r.pausedCallFrames.length-1));for(const e of g)s.appendResponseLine(e);return}v(""),v("üìö Call Stack:");const n=r.pausedCallFrames.length,a=Math.min(n,u),o=n>u;for(let e=0;e<a&&!b;e++){const n=r.pausedCallFrames[e],t=e===p?" ‚ñ∂":"";v(`   ${e}: ${n.functionName} at ${n.url||"(unknown)"}:${n.location.lineNumber+1}:${n.location.columnNumber??0}${t}`)}o&&!b&&v(`   ... and ${n-u} more frames`);const l=r.pausedCallFrames[p],L=await t(i);if(c>0&&!b){v("");try{const e=await m(L,l.location.scriptId);if(null===e)v(`‚ö†Ô∏è Source unavailable for script ${l.location.scriptId}`),v("   The script source could not be retrieved from the browser.");else{const n=f(e,{lineNumber:l.location.lineNumber+1,columnNumber:l.location.columnNumber??0,contextLines:c,formatMinified:!1}),t=h(n,l.location.lineNumber+1,l.location.columnNumber??0,l.url,l.functionName);R(t.split("\n"))}}catch(n){const t=n instanceof Error?n.message:String(n);v(`‚ö†Ô∏è Failed to retrieve code context: ${t}`),e(`[debugger] Error retrieving code context for script ${l.location.scriptId}: ${n}`)}}if(!b){v(""),v(`üì¶ Scope Variables (frame ${p}: ${l.functionName}):`);try{const{lines:e,hasTruncatedValues:n}=await inspectScopeVariablesOptimized(L,l.scopeChain,d);R(e),n&&!b&&(v(""),v("‚ÑπÔ∏è  Some values are truncated. Use get_scope_variables for full details or save_scope_variables to save to file."))}catch(n){const t=n instanceof Error?n.message:String(n);v(`   ‚ö†Ô∏è Failed to inspect scope variables: ${t}`),v("   Use get_scope_variables for detailed inspection."),e(`[debugger] Error inspecting scope variables: ${n}`)}}}for(const e of g)s.appendResponseLine(e);b&&(s.appendResponseLine(""),s.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${l} lines.`),s.appendResponseLine("   Use get_scope_variables for detailed variable inspection."),s.appendResponseLine(`   Increase maxOutputLines parameter to see more (current: ${l}).`))}});export const evaluateOnCallFrame=b({name:"evaluate_on_call_frame",description:"Evaluate a JavaScript expression in the context of a specific call frame when paused.",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{expression:n.string().describe("The JavaScript expression to evaluate."),frameIndex:n.number().int().nonnegative().default(0).describe("The index of the call frame to evaluate in (0 = current frame).")},handler:async(e,n,a)=>{const{expression:s,frameIndex:o}=e.params,i=a.getSelectedPage(),r=L(i);if(!r.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!r.pausedCallFrames||o>=r.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((r.pausedCallFrames?.length??1)-1));const p=r.pausedCallFrames[o],c=await t(i);try{const e=await c.send("Debugger.evaluateOnCallFrame",{callFrameId:p.callFrameId,expression:s,returnByValue:!0});e.exceptionDetails?(n.appendResponseLine("‚ùå Evaluation error:"),n.appendResponseLine(`   ${e.exceptionDetails.exception?.description||e.exceptionDetails.text}`)):(n.appendResponseLine(`‚úÖ Result (frame ${o}: ${p.functionName}):`),n.appendResponseLine("```json"),n.appendResponseLine(JSON.stringify(e.result?.value??e.result,null,2)),n.appendResponseLine("```"))}catch(e){n.appendResponseLine(`‚ùå Failed to evaluate: ${e instanceof Error?e.message:String(e)}`)}}});export const getScopeVariables=b({name:"get_scope_variables",description:"Get detailed variable information from a specific scope when paused at a breakpoint. Supports pagination and search.",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),scopeType:n.enum(["local","closure","block","script","global","catch","with","module","wasm-expression-stack"]).optional().describe("Filter to a specific scope type. If omitted, shows all scopes."),variableName:n.string().optional().describe("Specific variable name to inspect in detail. If omitted, shows all variables."),searchTerm:n.string().optional().describe("Search term to filter variable names (case-insensitive substring match)."),pageSize:n.number().int().positive().optional().describe("Maximum number of variables to return per page. When omitted, uses default page size."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based). When omitted, returns the first page."),maxDepth:n.number().int().positive().default(3).optional().describe("Maximum depth for nested object inspection. Default is 3."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated with a hint to use saveToFile."),saveToFile:n.string().optional().describe("Optional file path to save full output. When provided, saves complete output to file without truncation.")},handler:async(e,n,a)=>{const{frameIndex:o,scopeType:i,variableName:r,searchTerm:p,pageSize:c,pageIdx:l,maxDepth:u,maxOutputLines:d,saveToFile:m}=e.params,g=a.getSelectedPage(),b=L(g);if(!b.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!b.pausedCallFrames||o>=b.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((b.pausedCallFrames?.length??1)-1));const f=b.pausedCallFrames[o],h=await t(g),R=[],y=d??100;async function $(e,n,t){const a=[];if(n<=0)return a.push(`${t}[max depth reached]`),a;try{const s=(await h.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;if("object"===s.type&&s.objectId&&"null"!==s.subtype){a.push(`${t}${e.name}: (${s.subtype||s.type}) ${s.description||""}`);const o=await $(s.objectId,n-1,t+"  ");a.push(...o)}else{const{formatted:n,type:o}=v(s,1e4);a.push(`${t}${e.name}: (${o}) ${n}`)}}else e.get&&a.push(`${t}${e.name}: [getter]`)}catch(e){const n=e instanceof Error?e.message:String(e);a.push(`${t}(unable to retrieve properties: ${n})`)}return a}R.push(`üì¶ Scope Variables (frame ${o}: ${f.functionName}):`),R.push("");for(const e of f.scopeChain){if(i&&e.type!==i)continue;const n=e.name?`${e.type}: ${e.name}`:e.type;if(R.push(`=== [${n}] ===`),e.object.objectId){try{let n=(await h.send("Runtime.getProperties",{objectId:e.object.objectId,ownProperties:!0,generatePreview:!0})).result||[];if(r){const e=n.find(e=>e.name===r);if(e){if(R.push(`Variable: ${r}`),e.value){const n=e.value;if("object"===n.type&&n.objectId&&"null"!==n.subtype){R.push(`Type: ${n.subtype||n.type}`),R.push(`Description: ${n.description||"N/A"}`),R.push("Properties:");const e=await $(n.objectId,u??3,"   ");R.push(...e)}else{const{formatted:e,type:t}=v(n,1e5);R.push(`Type: ${t}`),R.push(`Value: ${e}`)}}}else R.push(`   Variable "${r}" not found in this scope.`)}else{if(p){const e=p.toLowerCase();if(n=n.filter(n=>n.name.toLowerCase().includes(e)),0===n.length){R.push(`   No variables matching "${p}" found.`),R.push("");continue}}const e=s(n,{pageSize:c,pageIdx:l});e.totalPages>1&&(R.push(`Showing ${e.startIndex+1}-${e.endIndex} of ${n.length} variables (Page ${e.currentPage+1} of ${e.totalPages})`),e.hasNextPage&&R.push(`Next page: pageIdx=${e.currentPage+1}`),e.hasPreviousPage&&R.push("Previous page: pageIdx="+(e.currentPage-1)));for(const n of e.items)if(n.value){const e=n.value;if("object"===e.type&&e.objectId&&"null"!==e.subtype){R.push(`${n.name}: (${e.subtype||e.type}) ${e.description||""}`);const t=await $(e.objectId,(u??3)-1,"   ");R.push(...t)}else{const{formatted:t,type:a}=v(e,1e4);R.push(`${n.name}: (${a}) ${t}`)}}else n.get&&R.push(`${n.name}: [getter]`)}}catch(e){R.push(`   (error retrieving properties: ${e instanceof Error?e.message:String(e)})`)}R.push("")}else R.push("   (no properties)"),R.push("")}if(m){const e=R.join("\n");await a.saveFile((new TextEncoder).encode(e),m),n.appendResponseLine(`‚úÖ Full output saved to ${m} (${R.length} lines)`),n.appendResponseLine("")}const x=R.length>y,S=x?R.slice(0,y):R;for(const e of S)n.appendResponseLine(e);x&&(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${y} of ${R.length} lines.`),n.appendResponseLine("   Use saveToFile parameter to save full output, or increase maxOutputLines."),m||n.appendResponseLine('   Example: get_scope_variables({ saveToFile: "/tmp/scope_vars.txt" })'))}});export const saveScopeVariables=b({name:"save_scope_variables",description:"Save all scope variables from the current debug context to a JSON file.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{filePath:n.string().describe("Absolute or relative file path to save the scope variables JSON."),frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),maxDepth:n.number().int().positive().default(5).optional().describe("Maximum depth for nested object serialization. Default is 5."),includeGlobal:n.boolean().default(!1).optional().describe("Include global scope variables. Default is false (globals are very large).")},handler:async(e,n,a)=>{const{filePath:s,frameIndex:o,maxDepth:i,includeGlobal:r}=e.params,p=a.getSelectedPage(),c=L(p);if(!c.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!c.pausedCallFrames||o>=c.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((c.pausedCallFrames?.length??1)-1));const l=c.pausedCallFrames[o],u=await t(p);async function d(e,n,t){if(n<=0||t.has(e))return"[max depth or circular reference]";t.add(e);const a={};try{const s=(await u.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;"object"===s.type&&s.objectId&&"null"!==s.subtype?(s.subtype,a[e.name]=await d(s.objectId,n-1,t)):void 0!==s.value?a[e.name]=s.value:s.unserializableValue?a[e.name]=`[${s.unserializableValue}]`:a[e.name]=`[${s.subtype||s.type}]`}else e.get&&(a[e.name]="[getter]")}catch{return"[error serializing]"}return a}const m={frame:{index:o,functionName:l.functionName,url:l.url,location:{lineNumber:l.location.lineNumber+1,columnNumber:l.location.columnNumber??0}},scopes:{}};for(const e of l.scopeChain){if("global"===e.type&&!r){m.scopes[e.type]="[skipped - use includeGlobal:true to include]";continue}const n=e.name?`${e.type}:${e.name}`:e.type;e.object.objectId?m.scopes[n]=await d(e.object.objectId,i??5,new Set):m.scopes[n]={}}const g=JSON.stringify(m,null,2);await a.saveFile((new TextEncoder).encode(g),s),n.appendResponseLine(`‚úÖ Saved scope variables to ${s}`),n.appendResponseLine(`   Frame: ${l.functionName}`),n.appendResponseLine(`   Scopes saved: ${Object.keys(m.scopes).join(", ")}`)}});export const pauseOnExceptions=b({name:"pause_on_exceptions",description:"Configure whether the debugger should pause on exceptions (none, uncaught, or all).",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{state:n.enum(["none","uncaught","all"]).describe("When to pause on exceptions.")},handler:async(e,n,t)=>{const{state:a}=e.params,s=t.getSelectedPage(),o=await $(s);try{switch(await o.send("Debugger.setPauseOnExceptions",{state:a}),n.appendResponseLine(`‚úÖ Exception pausing set to: ${a}`),a){case"none":n.appendResponseLine("   Debugger will not pause on any exceptions.");break;case"uncaught":n.appendResponseLine("   Debugger will pause only on uncaught exceptions.");break;case"all":n.appendResponseLine("   Debugger will pause on all exceptions (caught and uncaught).")}}catch(e){n.appendResponseLine(`‚ùå Failed to set exception pausing: ${e instanceof Error?e.message:String(e)}`)}}});export const disableDebugger=b({name:"disable_debugger",description:"Disable the JavaScript debugger on the current page and remove all breakpoints.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),o=L(s);if(!o.enabled)return void n.appendResponseLine("‚ÑπÔ∏è Debugger is already disabled.");const i=await t(s);try{await i.send("Debugger.disable"),o.enabled=!1,o.breakpoints.clear(),o.isPaused=!1,o.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Debugger disabled."),n.appendResponseLine("   All breakpoints have been removed.")}catch(e){n.appendResponseLine(`‚ùå Failed to disable debugger: ${e instanceof Error?e.message:String(e)}`)}}});export const getPossibleBreakpoints=b({name:"get_possible_breakpoints",description:"Discover all valid breakpoint locations in a script at a specific line. Useful for minified code.",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to search for breakpoints (1-based, as shown in editors)."),startColumn:n.number().int().nonnegative().optional().describe("Optional start column to filter results (0-based). Defaults to 0."),endColumn:n.number().int().nonnegative().optional().describe("Optional end column to filter results (0-based). Defaults to end of line."),maxCount:n.number().int().positive().optional().describe("Maximum number of locations to return. Defaults to 20.")},handler:async(e,n,t)=>{const{urlRegex:a,lineNumber:s,startColumn:o,endColumn:i,maxCount:p=20}=e.params,l=t.getSelectedPage(),u=await $(l);if(void 0!==o&&o<0)return n.appendResponseLine(`‚ùå Invalid startColumn: ${o}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Use startColumn=0 to search from the beginning of the line.");if(void 0!==i&&i<0)return n.appendResponseLine(`‚ùå Invalid endColumn: ${i}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Omit endColumn to search to the end of the line.");if(void 0!==o&&void 0!==i&&o>i)return n.appendResponseLine(`‚ùå Invalid column range: startColumn (${o}) > endColumn (${i})`),n.appendResponseLine("   startColumn must be less than or equal to endColumn."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Swap the values or adjust the range.");const d=s-1,m=await r(u,a);if(0===m.length)return n.appendResponseLine(`‚ùå No scripts found matching pattern: ${a}`),void n.appendResponseLine("   üí° Suggestion: Verify the script is loaded and the URL pattern is correct.");let g=[];for(const e of m){const n=o??0,t=i??n+100,a=(await c(u,e.scriptId,d,n,d,t,e.url)).filter(e=>!(void 0!==o&&e.columnNumber<o)&&!(void 0!==i&&e.columnNumber>i));g=g.concat(a)}if(0===g.length)return n.appendResponseLine(`‚ùå No valid breakpoint locations found at line ${s}`),void 0===o&&void 0===i||n.appendResponseLine(`   Column range: ${o??0} - ${i??"end"}`),void n.appendResponseLine("   üí° Suggestion: Try a different line or expand the column range.");g.sort((e,n)=>{const t=e.scriptUrl.localeCompare(n.scriptUrl);return 0!==t?t:e.columnNumber-n.columnNumber});const b=g.length,f=b>p,h=f?g.slice(0,p):g;n.appendResponseLine(`üìç Possible breakpoint locations at line ${s}:`),n.appendResponseLine(`   URL pattern: ${a}`),void 0===o&&void 0===i||n.appendResponseLine(`   Column range: ${o??0} - ${i??"end"}`),n.appendResponseLine("");for(const e of h)n.appendResponseLine(`   ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`);f?(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Results truncated: showing ${p} of ${b} locations`),n.appendResponseLine("   üí° Suggestion: Use startColumn/endColumn to narrow the search range.")):(n.appendResponseLine(""),n.appendResponseLine(`Found ${b} valid breakpoint location(s).`))}});export async function ensureDebuggerEnabledForPage(e){await $(e)}
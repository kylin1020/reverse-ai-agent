/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as n}from"../third_party/index.js";import{getCdpSession as t}from"../utils/cdp.js";import{getConfig as a}from"../utils/config.js";import{paginate as s}from"../utils/pagination.js";import{ToolCategory as i}from"./categories.js";import{findMatchingScripts as o,findNearestBreakpointLocation as r,queryPossibleBreakpoints as p,cacheScript as l,clearScriptCache as c,getScriptCache as d}from"./smartBreakpointUtils.js";import{defineTool as u}from"./ToolDefinition.js";function m(e,n=a().maxInlineStringLength){const t=e.type||"unknown",s=e.subtype;if(void 0!==e.value){const s=function(e,n=a().maxInlineStringLength){if(void 0===e)return{formatted:"undefined",truncated:!1};if(null===e)return{formatted:"null",truncated:!1};let t;if("string"==typeof e)t=JSON.stringify(e);else if("object"==typeof e)try{t=JSON.stringify(e)}catch{t=String(e)}else t=String(e);return t.length>n?{formatted:t.substring(0,n)+"...",truncated:!0}:{formatted:t,truncated:!1}}(e.value,n);return{...s,type:t}}if(e.unserializableValue)return{formatted:e.unserializableValue,truncated:!1,type:t};if(e.preview){const a=e.preview;if(a.overflow){return{formatted:`{${(a.properties||[]).slice(0,5).map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}, ...}`,truncated:!0,type:s||t}}if(a.properties){const e=`{${a.properties.map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}}`;return e.length>n?{formatted:e.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:e,truncated:!1,type:s||t}}}if(e.description){const a=e.description;return a.length>n?{formatted:a.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:a,truncated:!1,type:s||t}}return{formatted:`[${s||t}]`,truncated:!1,type:s||t}}const g=new WeakMap;function b(e){let n=g.get(e);return n||(n={enabled:!1,breakpoints:new Map,isPaused:!1},g.set(e,n)),n}const f=new WeakSet;async function h(n){const a=await t(n),s=b(n);if(s.enabled||(await a.send("Debugger.enable"),s.enabled=!0,a.on("Debugger.scriptParsed",n=>{l(a,{scriptId:n.scriptId,url:n.url||"",startLine:n.startLine,startColumn:n.startColumn,endLine:n.endLine,endColumn:n.endColumn}),e(`[debugger] Script parsed: ${n.url||n.scriptId}`)}),a.on("Debugger.paused",n=>{s.isPaused=!0,s.pausedCallFrames=n.callFrames?.map(e=>({callFrameId:e.callFrameId,functionName:e.functionName||"(anonymous)",location:{scriptId:e.location.scriptId,lineNumber:e.location.lineNumber,columnNumber:e.location.columnNumber},url:e.url||"",scopeChain:e.scopeChain?.map(e=>({type:e.type,object:{type:e.object?.type,objectId:e.object?.objectId},name:e.name}))||[]})),e("[debugger] Execution paused at breakpoint")}),a.on("Debugger.resumed",()=>{s.isPaused=!1,s.pausedCallFrames=void 0,e("[debugger] Execution resumed")})),!f.has(n)){let t;f.add(n);try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}a.on("Page.frameStartedLoading",async i=>{let o=!t||i.frameId===t;if(!o)try{const e=await a.send("Page.getFrameTree"),n=e.frameTree?.frame?.id;i.frameId===n&&(o=!0,t=n)}catch{o=!0}if(o){if(c(a),e("[debugger] Script cache cleared on navigation (including analysis cache)"),s.breakpoints.size>0){e("[debugger] Main frame started loading, restoring breakpoints immediately...");try{await async function(n,t){const a=b(n);try{await t.send("Emulation.setScriptExecutionDisabled",{value:!0}),e("[debugger] Script execution disabled temporarily")}catch{}try{await t.send("Debugger.enable")}catch{}for(const[n,s]of a.breakpoints)try{const a={lineNumber:s.resolvedLineNumber-1,urlRegex:s.urlPattern,columnNumber:s.resolvedColumnNumber};s.condition&&(a.condition=s.condition);const i=await t.send("Debugger.setBreakpointByUrl",a);s.breakpointId=i.breakpointId,e(`[debugger] Restored breakpoint "${n}" after navigation`)}catch(t){e(`[debugger] Failed to restore breakpoint "${n}": ${t}`)}try{await t.send("Emulation.setScriptExecutionDisabled",{value:!1}),e("[debugger] Script execution re-enabled")}catch{}}(n,a)}catch(n){e(`[debugger] Error restoring breakpoints: ${n}`)}}try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}}});try{await a.send("Page.enable")}catch{}}return a}export const setBreakpoint=u({name:"set_breakpoint",description:'Set a JavaScript breakpoint at a specific line in a file matching a URL pattern.\n\nThe breakpoint will cause code execution to pause when that line is reached.\nUse url_regex to match files (e.g., ".*app\\.js.*" matches URLs containing "app.js").\n\nSmart Snapping: When you specify a columnNumber, the tool will automatically "snap" to the\nnearest valid breakpoint position if the exact position isn\'t valid. This is especially useful\nfor minified/single-line JavaScript where valid breakpoint positions may not be obvious.\n\nNote: Line numbers in CDP are 0-based, so line 10 in your editor = lineNumber 9.\nThis tool automatically converts 1-based line numbers to 0-based for convenience.\n\nExample:\n- Set breakpoint at line 25 of main.js: urlRegex=".*main\\.js.*", lineNumber=25\n- Set conditional breakpoint: urlRegex=".*api\\.js.*", lineNumber=42, condition="response.status !== 200"\n- Set breakpoint with column snapping: urlRegex=".*minified\\.js.*", lineNumber=1, columnNumber=500',annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("A unique identifier for this breakpoint (used to remove it later)."),urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to set the breakpoint at (1-based, as shown in editors)."),columnNumber:n.number().int().nonnegative().optional().describe("Optional target column number (0-based) for smart snapping. When specified, the tool will find the nearest valid breakpoint position within snapRange of this column."),snapRange:n.number().int().positive().optional().describe("Search range around the target column for finding valid breakpoint positions. Defaults to 100."),condition:n.string().optional().describe("Optional JavaScript expression. The breakpoint only triggers when this evaluates to true.")},handler:async(e,n,t)=>{const{breakpointId:a,urlRegex:s,lineNumber:i,columnNumber:l,snapRange:c=100,condition:u}=e.params,m=t.getSelectedPage(),g=await h(m),f=b(m);if(void 0!==l&&l<0)return n.appendResponseLine(`‚ùå Invalid column number: ${l}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid column positions"),void n.appendResponseLine("   ‚Ä¢ Column 0 represents the start of the line");const v=i-1,R=l??0;let L=R,y=!1;if(void 0!==l){const e=await o(g,s);if(0===e.length)return n.appendResponseLine(`‚ùå Failed to set breakpoint: No scripts found matching pattern "${s}"`),n.appendResponseLine(`   Requested position: line ${i}, column ${l}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded in the page"),n.appendResponseLine("   ‚Ä¢ Check that the URL pattern is correct (use regex syntax)"),void n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations");const t=Math.max(0,R-c),a=R+c;let d=[];for(const n of e){const e=await p(g,n.scriptId,v,t,v,a,n.url);d=d.concat(e)}if(0===d.length)return n.appendResponseLine("‚ùå Failed to set breakpoint: No valid breakpoint positions found"),n.appendResponseLine(`   Requested position: line ${i}, column ${l}`),n.appendResponseLine(`   Search range: columns ${t} - ${a}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations on this line"),n.appendResponseLine(`   ‚Ä¢ Try increasing snapRange (currently ${c}) to search a wider area`),void n.appendResponseLine("   ‚Ä¢ Verify the line number contains executable code");const u=r(d,R);u&&(L=u.columnNumber,y=L!==R)}const $={lineNumber:v,urlRegex:s,columnNumber:L};u&&($.condition=u);try{const e=await g.send("Debugger.setBreakpointByUrl",$),t=e.locations;if(t&&t.length>0){const o=t[0],r=o.lineNumber+1,p=o.columnNumber,c=y||r!==i||p!==L,m={breakpointId:e.breakpointId,urlPattern:s,lineNumber:i,columnNumber:l,resolvedLineNumber:r,resolvedColumnNumber:p,condition:u,wasSnapped:c};f.breakpoints.set(a,m),n.appendResponseLine(`‚úÖ Breakpoint "${a}" set successfully`),c&&n.appendResponseLine("‚ö° Snapped to nearest valid position"),n.appendResponseLine(`   URL pattern: ${s}`),void 0!==l?(n.appendResponseLine(`   Requested: line ${i}, column ${l}`),n.appendResponseLine(`   Resolved:  line ${r}, column ${p}`)):(n.appendResponseLine(`   Line: ${i}`),r!==i&&n.appendResponseLine(`   Resolved line: ${r}`)),u&&n.appendResponseLine(`   Condition: ${u}`),n.appendResponseLine(`   CDP breakpoint ID: ${e.breakpointId}`),n.appendResponseLine(""),n.appendResponseLine("üìç Resolved locations:");for(const e of t){const t=d(g).get(e.scriptId),a=t?.url||`Script ${e.scriptId}`;n.appendResponseLine(`   ${a}:${e.lineNumber+1}:${e.columnNumber}`)}}else await g.send("Debugger.removeBreakpoint",{breakpointId:e.breakpointId}),n.appendResponseLine("‚ùå Failed to set breakpoint: No matching scripts found"),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${i}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the URL pattern matches a loaded script"),n.appendResponseLine("   ‚Ä¢ Check that the line number contains executable code"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations")}catch(e){n.appendResponseLine(`‚ùå Failed to set breakpoint: ${e instanceof Error?e.message:String(e)}`),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${i}`),void 0!==l&&n.appendResponseLine(`   Column: ${l}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded and the URL pattern is correct")}}});export const removeBreakpoint=u({name:"remove_breakpoint",description:"Remove a previously set JavaScript breakpoint by its ID.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("The ID of the breakpoint to remove (as specified when setting it).")},handler:async(e,n,a)=>{const{breakpointId:s}=e.params,i=a.getSelectedPage(),o=b(i),r=o.breakpoints.get(s);if(!r)return void n.appendResponseLine(`‚ö†Ô∏è Breakpoint "${s}" not found.`);const p=await t(i);try{await p.send("Debugger.removeBreakpoint",{breakpointId:r.breakpointId}),o.breakpoints.delete(s),n.appendResponseLine(`‚úÖ Removed breakpoint "${s}"`)}catch(e){n.appendResponseLine(`‚ùå Failed to remove breakpoint: ${e instanceof Error?e.message:String(e)}`)}}});export const listBreakpoints=u({name:"list_breakpoints",description:"List all active JavaScript breakpoints on the current page. Supports pagination and search.",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{searchTerm:n.string().optional().describe("Search term to filter breakpoints by ID or URL pattern (case-insensitive)."),pageSize:n.number().int().positive().optional().describe("Maximum number of breakpoints to return per page."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,n,t)=>{const{searchTerm:a,pageSize:i,pageIdx:o}=e.params,r=b(t.getSelectedPage());if(0===r.breakpoints.size)return void n.appendResponseLine("No active breakpoints.");let p=Array.from(r.breakpoints.entries());if(a){const e=a.toLowerCase();if(p=p.filter(([n,t])=>n.toLowerCase().includes(e)||t.urlPattern.toLowerCase().includes(e)),0===p.length)return void n.appendResponseLine(`No breakpoints matching "${a}" found.`)}const l=s(p,{pageSize:i,pageIdx:o});n.appendResponseLine(`Active breakpoints (${p.length} total):`),l.totalPages>1&&(n.appendResponseLine(`Showing ${l.startIndex+1}-${l.endIndex} (Page ${l.currentPage+1} of ${l.totalPages})`),l.hasNextPage&&n.appendResponseLine(`Next page: pageIdx=${l.currentPage+1}`)),n.appendResponseLine("");for(const[e,t]of l.items)n.appendResponseLine(`üìç ${e}`),n.appendResponseLine(`   URL pattern: ${t.urlPattern}`),n.appendResponseLine(`   Line: ${t.lineNumber}`),void 0!==t.columnNumber&&n.appendResponseLine(`   Column: ${t.columnNumber}`),t.condition&&n.appendResponseLine(`   Condition: ${t.condition}`),n.appendResponseLine("")}});export const clearAllBreakpoints=u({name:"clear_all_breakpoints",description:"Remove all active JavaScript breakpoints on the current page.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=b(s),o=await t(s),r=i.breakpoints.size,p=[];for(const[e,n]of i.breakpoints)try{await o.send("Debugger.removeBreakpoint",{breakpointId:n.breakpointId})}catch(n){p.push(`${e}: ${n instanceof Error?n.message:String(n)}`)}if(i.breakpoints.clear(),p.length>0){n.appendResponseLine(`‚ö†Ô∏è Cleared ${r-p.length}/${r} breakpoints.`),n.appendResponseLine("Errors:");for(const e of p)n.appendResponseLine(`   ${e}`)}else n.appendResponseLine(`‚úÖ Cleared ${r} breakpoint(s).`)}});export const resumeExecution=u({name:"resume_execution",description:"Resume JavaScript execution after hitting a breakpoint.\n\nUse this when the debugger is paused at a breakpoint to continue running the code.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=b(s);if(!i.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.resume"),i.isPaused=!1,i.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Execution resumed.")}catch(e){n.appendResponseLine(`‚ùå Failed to resume: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOver=u({name:"step_over",description:"Step over to the next line of code (doesn't step into function calls).\n\nUse this when paused at a breakpoint to execute the current line and move to the next.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!b(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepOver"),n.appendResponseLine("‚úÖ Stepped over to next line.")}catch(e){n.appendResponseLine(`‚ùå Failed to step over: ${e instanceof Error?e.message:String(e)}`)}}});export const stepInto=u({name:"step_into",description:"Step into a function call at the current line.\n\nUse this when paused at a breakpoint and the current line has a function call you want to debug.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!b(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepInto"),n.appendResponseLine("‚úÖ Stepped into function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step into: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOut=u({name:"step_out",description:"Step out of the current function.\n\nUse this when paused inside a function and you want to return to the caller.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!b(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepOut"),n.appendResponseLine("‚úÖ Stepped out of function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step out: ${e instanceof Error?e.message:String(e)}`)}}});export const getDebuggerStatus=u({name:"get_debugger_status",description:"Get the current status of the JavaScript debugger.\n\nReturns whether the debugger is enabled, paused, and shows:\n- Current call stack if paused\n- Local variables and scope information for the current frame\n- Values are truncated if too long; use get_scope_variables for full details",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).optional().describe("The call frame index to show variables for (0 = current frame). Default is 0.")},handler:async(e,n,s)=>{const i=s.getSelectedPage(),o=b(i),r=e.params.frameIndex??0;if(n.appendResponseLine("üîç Debugger Status:"),n.appendResponseLine("   Enabled: "+(o.enabled?"Yes":"No")),n.appendResponseLine("   Paused: "+(o.isPaused?"Yes":"No")),n.appendResponseLine(`   Active breakpoints: ${o.breakpoints.size}`),o.isPaused&&o.pausedCallFrames){n.appendResponseLine(""),n.appendResponseLine("üìö Call Stack:");for(let e=0;e<o.pausedCallFrames.length;e++){const t=o.pausedCallFrames[e],a=e===r?" ‚ñ∂":"";n.appendResponseLine(`   ${e}: ${t.functionName} at ${t.url||"(unknown)"}:${t.location.lineNumber+1}:${t.location.columnNumber??0}${a}`)}if(r<o.pausedCallFrames.length){const e=o.pausedCallFrames[r],s=await t(i);n.appendResponseLine(""),n.appendResponseLine(`üì¶ Scope Variables (frame ${r}: ${e.functionName}):`);let p=!1;for(const t of e.scopeChain){if("global"===t.type){n.appendResponseLine(`   [${t.type}] (use get_scope_variables to inspect)`);continue}const e=t.name?`${t.type}: ${t.name}`:t.type;if(n.appendResponseLine(`   [${e}]`),t.object.objectId)try{const e=(await s.send("Runtime.getProperties",{objectId:t.object.objectId,ownProperties:!0,generatePreview:!0})).result||[],i=a().maxProperties,o=e.slice(0,i),r=e.length>i;for(const e of o)if(e.value){const{formatted:t,truncated:a,type:s}=m(e.value);p=p||a;const i=a?" [truncated]":"";n.appendResponseLine(`      ${e.name}: (${s}) ${t}${i}`)}else e.get&&n.appendResponseLine(`      ${e.name}: [getter]`);r&&(n.appendResponseLine(`      ... and ${e.length-i} more properties`),p=!0)}catch{n.appendResponseLine("      (unable to retrieve properties)")}}p&&(n.appendResponseLine(""),n.appendResponseLine("‚ÑπÔ∏è  Some values are truncated. Use get_scope_variables for full details or save_scope_variables to save to file."))}}}});export const evaluateOnCallFrame=u({name:"evaluate_on_call_frame",description:"Evaluate a JavaScript expression in the context of a specific call frame when paused.\n\nThis allows you to inspect variables and state at any point in the call stack.\nUse frameIndex 0 for the current (topmost) frame, 1 for the caller, etc.",annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{expression:n.string().describe("The JavaScript expression to evaluate."),frameIndex:n.number().int().nonnegative().default(0).describe("The index of the call frame to evaluate in (0 = current frame).")},handler:async(e,n,a)=>{const{expression:s,frameIndex:i}=e.params,o=a.getSelectedPage(),r=b(o);if(!r.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!r.pausedCallFrames||i>=r.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((r.pausedCallFrames?.length??1)-1));const p=r.pausedCallFrames[i],l=await t(o);try{const e=await l.send("Debugger.evaluateOnCallFrame",{callFrameId:p.callFrameId,expression:s,returnByValue:!0});e.exceptionDetails?(n.appendResponseLine("‚ùå Evaluation error:"),n.appendResponseLine(`   ${e.exceptionDetails.exception?.description||e.exceptionDetails.text}`)):(n.appendResponseLine(`‚úÖ Result (frame ${i}: ${p.functionName}):`),n.appendResponseLine("```json"),n.appendResponseLine(JSON.stringify(e.result?.value??e.result,null,2)),n.appendResponseLine("```"))}catch(e){n.appendResponseLine(`‚ùå Failed to evaluate: ${e instanceof Error?e.message:String(e)}`)}}});export const getScopeVariables=u({name:"get_scope_variables",description:'Get detailed variable information from a specific scope when paused at a breakpoint.\n\nUse this to inspect variables in full detail, including nested objects and long strings.\nYou can also inspect a specific variable by name to see its complete value.\nSupports pagination and search to handle large numbers of variables.\n\nScope types:\n- "local": Variables declared in the current function\n- "closure": Variables from enclosing scopes (closures)\n- "block": Block-scoped variables (let/const in blocks)\n- "script": Script-level variables\n- "global": Global variables (window object properties)',annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),scopeType:n.enum(["local","closure","block","script","global","catch","with","module","wasm-expression-stack"]).optional().describe("Filter to a specific scope type. If omitted, shows all scopes."),variableName:n.string().optional().describe("Specific variable name to inspect in detail. If omitted, shows all variables."),searchTerm:n.string().optional().describe("Search term to filter variable names (case-insensitive substring match)."),pageSize:n.number().int().positive().optional().describe("Maximum number of variables to return per page. When omitted, uses default page size."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based). When omitted, returns the first page."),maxDepth:n.number().int().positive().default(3).optional().describe("Maximum depth for nested object inspection. Default is 3."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated with a hint to use saveToFile."),saveToFile:n.string().optional().describe("Optional file path to save full output. When provided, saves complete output to file without truncation.")},handler:async(e,n,a)=>{const{frameIndex:i,scopeType:o,variableName:r,searchTerm:p,pageSize:l,pageIdx:c,maxDepth:d,maxOutputLines:u,saveToFile:g}=e.params,f=a.getSelectedPage(),h=b(f);if(!h.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!h.pausedCallFrames||i>=h.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((h.pausedCallFrames?.length??1)-1));const v=h.pausedCallFrames[i],R=await t(f),L=[],y=u??100;async function $(e,n,t){const a=[];if(n<=0)return a.push(`${t}[max depth reached]`),a;try{const s=(await R.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;if("object"===s.type&&s.objectId&&"null"!==s.subtype){a.push(`${t}${e.name}: (${s.subtype||s.type}) ${s.description||""}`);const i=await $(s.objectId,n-1,t+"  ");a.push(...i)}else{const{formatted:n,type:i}=m(s,1e4);a.push(`${t}${e.name}: (${i}) ${n}`)}}else e.get&&a.push(`${t}${e.name}: [getter]`)}catch{a.push(`${t}(unable to retrieve properties)`)}return a}L.push(`üì¶ Scope Variables (frame ${i}: ${v.functionName}):`),L.push("");for(const e of v.scopeChain){if(o&&e.type!==o)continue;const n=e.name?`${e.type}: ${e.name}`:e.type;if(L.push(`=== [${n}] ===`),e.object.objectId){try{let n=(await R.send("Runtime.getProperties",{objectId:e.object.objectId,ownProperties:!0,generatePreview:!0})).result||[];if(r){const e=n.find(e=>e.name===r);if(e){if(L.push(`Variable: ${r}`),e.value){const n=e.value;if("object"===n.type&&n.objectId&&"null"!==n.subtype){L.push(`Type: ${n.subtype||n.type}`),L.push(`Description: ${n.description||"N/A"}`),L.push("Properties:");const e=await $(n.objectId,d??3,"   ");L.push(...e)}else{const{formatted:e,type:t}=m(n,1e5);L.push(`Type: ${t}`),L.push(`Value: ${e}`)}}}else L.push(`   Variable "${r}" not found in this scope.`)}else{if(p){const e=p.toLowerCase();if(n=n.filter(n=>n.name.toLowerCase().includes(e)),0===n.length){L.push(`   No variables matching "${p}" found.`),L.push("");continue}}const e=s(n,{pageSize:l,pageIdx:c});e.totalPages>1&&(L.push(`Showing ${e.startIndex+1}-${e.endIndex} of ${n.length} variables (Page ${e.currentPage+1} of ${e.totalPages})`),e.hasNextPage&&L.push(`Next page: pageIdx=${e.currentPage+1}`),e.hasPreviousPage&&L.push("Previous page: pageIdx="+(e.currentPage-1)));for(const n of e.items)if(n.value){const e=n.value;if("object"===e.type&&e.objectId&&"null"!==e.subtype){L.push(`${n.name}: (${e.subtype||e.type}) ${e.description||""}`);const t=await $(e.objectId,(d??3)-1,"   ");L.push(...t)}else{const{formatted:t,type:a}=m(e,1e4);L.push(`${n.name}: (${a}) ${t}`)}}else n.get&&L.push(`${n.name}: [getter]`)}}catch(e){L.push(`   (error retrieving properties: ${e instanceof Error?e.message:String(e)})`)}L.push("")}else L.push("   (no properties)"),L.push("")}if(g){const e=L.join("\n");await a.saveFile((new TextEncoder).encode(e),g),n.appendResponseLine(`‚úÖ Full output saved to ${g} (${L.length} lines)`),n.appendResponseLine("")}const x=L.length>y,w=x?L.slice(0,y):L;for(const e of w)n.appendResponseLine(e);x&&(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${y} of ${L.length} lines.`),n.appendResponseLine("   Use saveToFile parameter to save full output, or increase maxOutputLines."),g||n.appendResponseLine('   Example: get_scope_variables({ saveToFile: "/tmp/scope_vars.txt" })'))}});export const saveScopeVariables=u({name:"save_scope_variables",description:"Save all scope variables from the current debug context to a JSON file.\n\nThis is useful for capturing the complete state of variables for analysis, especially when dealing with large objects or binary data.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{filePath:n.string().describe("Absolute or relative file path to save the scope variables JSON."),frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),maxDepth:n.number().int().positive().default(5).optional().describe("Maximum depth for nested object serialization. Default is 5."),includeGlobal:n.boolean().default(!1).optional().describe("Include global scope variables. Default is false (globals are very large).")},handler:async(e,n,a)=>{const{filePath:s,frameIndex:i,maxDepth:o,includeGlobal:r}=e.params,p=a.getSelectedPage(),l=b(p);if(!l.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!l.pausedCallFrames||i>=l.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((l.pausedCallFrames?.length??1)-1));const c=l.pausedCallFrames[i],d=await t(p);async function u(e,n,t){if(n<=0||t.has(e))return"[max depth or circular reference]";t.add(e);const a={};try{const s=(await d.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;"object"===s.type&&s.objectId&&"null"!==s.subtype?(s.subtype,a[e.name]=await u(s.objectId,n-1,t)):void 0!==s.value?a[e.name]=s.value:s.unserializableValue?a[e.name]=`[${s.unserializableValue}]`:a[e.name]=`[${s.subtype||s.type}]`}else e.get&&(a[e.name]="[getter]")}catch{return"[error serializing]"}return a}const m={frame:{index:i,functionName:c.functionName,url:c.url,location:{lineNumber:c.location.lineNumber+1,columnNumber:c.location.columnNumber??0}},scopes:{}};for(const e of c.scopeChain){if("global"===e.type&&!r){m.scopes[e.type]="[skipped - use includeGlobal:true to include]";continue}const n=e.name?`${e.type}:${e.name}`:e.type;e.object.objectId?m.scopes[n]=await u(e.object.objectId,o??5,new Set):m.scopes[n]={}}const g=JSON.stringify(m,null,2);await a.saveFile((new TextEncoder).encode(g),s),n.appendResponseLine(`‚úÖ Saved scope variables to ${s}`),n.appendResponseLine(`   Frame: ${c.functionName}`),n.appendResponseLine(`   Scopes saved: ${Object.keys(m.scopes).join(", ")}`)}});export const pauseOnExceptions=u({name:"pause_on_exceptions",description:'Configure whether the debugger should pause on exceptions.\n\nOptions:\n- "none": Never pause on exceptions\n- "uncaught": Only pause on uncaught exceptions\n- "all": Pause on all exceptions (caught and uncaught)',annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{state:n.enum(["none","uncaught","all"]).describe("When to pause on exceptions.")},handler:async(e,n,t)=>{const{state:a}=e.params,s=t.getSelectedPage(),i=await h(s);try{switch(await i.send("Debugger.setPauseOnExceptions",{state:a}),n.appendResponseLine(`‚úÖ Exception pausing set to: ${a}`),a){case"none":n.appendResponseLine("   Debugger will not pause on any exceptions.");break;case"uncaught":n.appendResponseLine("   Debugger will pause only on uncaught exceptions.");break;case"all":n.appendResponseLine("   Debugger will pause on all exceptions (caught and uncaught).")}}catch(e){n.appendResponseLine(`‚ùå Failed to set exception pausing: ${e instanceof Error?e.message:String(e)}`)}}});export const disableDebugger=u({name:"disable_debugger",description:"Disable the JavaScript debugger on the current page.\n\nThis removes all breakpoints and stops debugging. Use this when you're done debugging.",annotations:{category:i.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=b(s);if(!i.enabled)return void n.appendResponseLine("‚ÑπÔ∏è Debugger is already disabled.");const o=await t(s);try{await o.send("Debugger.disable"),i.enabled=!1,i.breakpoints.clear(),i.isPaused=!1,i.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Debugger disabled."),n.appendResponseLine("   All breakpoints have been removed.")}catch(e){n.appendResponseLine(`‚ùå Failed to disable debugger: ${e instanceof Error?e.message:String(e)}`)}}});export const getPossibleBreakpoints=u({name:"get_possible_breakpoints",description:'Discover all valid breakpoint locations in a script at a specific line.\n\nThis tool queries V8 for positions where breakpoints can actually be set, which is especially\nuseful for minified/single-line JavaScript where you need to find the exact column number.\n\nUse this before set_breakpoint to find valid positions, or when a breakpoint fails to resolve.\n\nExample:\n- Find breakpoints on line 1 of minified.js: urlRegex=".*minified\\.js.*", lineNumber=1\n- Find breakpoints in column range: urlRegex=".*app\\.js.*", lineNumber=10, startColumn=100, endColumn=200',annotations:{category:i.DEBUGGING,readOnlyHint:!0},schema:{urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to search for breakpoints (1-based, as shown in editors)."),startColumn:n.number().int().nonnegative().optional().describe("Optional start column to filter results (0-based). Defaults to 0."),endColumn:n.number().int().nonnegative().optional().describe("Optional end column to filter results (0-based). Defaults to end of line."),maxCount:n.number().int().positive().optional().describe("Maximum number of locations to return. Defaults to 20.")},handler:async(e,n,t)=>{const{urlRegex:a,lineNumber:s,startColumn:i,endColumn:r,maxCount:l=20}=e.params,c=t.getSelectedPage(),d=await h(c);if(void 0!==i&&i<0)return n.appendResponseLine(`‚ùå Invalid startColumn: ${i}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Use startColumn=0 to search from the beginning of the line.");if(void 0!==r&&r<0)return n.appendResponseLine(`‚ùå Invalid endColumn: ${r}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Omit endColumn to search to the end of the line.");if(void 0!==i&&void 0!==r&&i>r)return n.appendResponseLine(`‚ùå Invalid column range: startColumn (${i}) > endColumn (${r})`),n.appendResponseLine("   startColumn must be less than or equal to endColumn."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Swap the values or adjust the range.");const u=s-1,m=await o(d,a);if(0===m.length)return n.appendResponseLine(`‚ùå No scripts found matching pattern: ${a}`),void n.appendResponseLine("   üí° Suggestion: Verify the script is loaded and the URL pattern is correct.");let g=[];for(const e of m){const n=i??0,t=r??n+100,a=(await p(d,e.scriptId,u,n,u,t,e.url)).filter(e=>!(void 0!==i&&e.columnNumber<i)&&!(void 0!==r&&e.columnNumber>r));g=g.concat(a)}if(0===g.length)return n.appendResponseLine(`‚ùå No valid breakpoint locations found at line ${s}`),void 0===i&&void 0===r||n.appendResponseLine(`   Column range: ${i??0} - ${r??"end"}`),void n.appendResponseLine("   üí° Suggestion: Try a different line or expand the column range.");g.sort((e,n)=>{const t=e.scriptUrl.localeCompare(n.scriptUrl);return 0!==t?t:e.columnNumber-n.columnNumber});const b=g.length,f=b>l,v=f?g.slice(0,l):g;n.appendResponseLine(`üìç Possible breakpoint locations at line ${s}:`),n.appendResponseLine(`   URL pattern: ${a}`),void 0===i&&void 0===r||n.appendResponseLine(`   Column range: ${i??0} - ${r??"end"}`),n.appendResponseLine("");for(const e of v)n.appendResponseLine(`   ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`);f?(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Results truncated: showing ${l} of ${b} locations`),n.appendResponseLine("   üí° Suggestion: Use startColumn/endColumn to narrow the search range.")):(n.appendResponseLine(""),n.appendResponseLine(`Found ${b} valid breakpoint location(s).`))}});export async function ensureDebuggerEnabledForPage(e){await h(e)}
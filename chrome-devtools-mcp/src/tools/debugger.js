/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as t}from"../third_party/index.js";import{getCdpSession as n}from"../utils/cdp.js";import{getConfig as a}from"../utils/config.js";import{extractContextCode as s,formatContextCodeOutput as o}from"../utils/contextCodeUtils.js";import{getDebuggerState as i,initializeDebuggerForPage as r,getActiveBreakpoints as p,trackBreakpoint as l,untrackBreakpoint as c,clearTrackedBreakpoints as u}from"../utils/debuggerUtils.js";import{paginate as d}from"../utils/pagination.js";import{findMatchingScripts as m,findNearestBreakpointLocation as g,queryPossibleBreakpoints as b,getScriptCache as f,getScriptSource as h}from"../utils/smartBreakpointUtils.js";import{ToolCategory as v}from"./categories.js";import{defineTool as L}from"./ToolDefinition.js";function x(e,t=a().maxInlineStringLength){const n=e.type||"unknown",s=e.subtype;if(void 0!==e.value){const s=function(e,t=a().maxInlineStringLength){if(void 0===e)return{formatted:"undefined",truncated:!1};if(null===e)return{formatted:"null",truncated:!1};let n;if("string"==typeof e)n=JSON.stringify(e);else if("object"==typeof e)try{n=JSON.stringify(e)}catch{n=String(e)}else n=String(e);return n.length>t?{formatted:n.substring(0,t)+"...",truncated:!0}:{formatted:n,truncated:!1}}(e.value,t);return{...s,type:n}}if(e.unserializableValue)return{formatted:e.unserializableValue,truncated:!1,type:n};if(e.preview){const a=e.preview;if(a.overflow){return{formatted:`{${(a.properties||[]).slice(0,5).map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}, ...}`,truncated:!0,type:s||n}}if(a.properties){const e=`{${a.properties.map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}}`;return e.length>t?{formatted:e.substring(0,t)+"...",truncated:!0,type:s||n}:{formatted:e,truncated:!1,type:s||n}}}if(e.description){const a=e.description;return a.length>t?{formatted:a.substring(0,t)+"...",truncated:!0,type:s||n}:{formatted:a,truncated:!1,type:s||n}}return{formatted:`[${s||n}]`,truncated:!1,type:s||n}}export const DEFAULT_COMPACT_DEBUG_CONFIG={maxCallStackDepth:4,contextLines:2,maxLocalVariables:5,maxValueLength:100,showStatus:!0};export function getCompactCallStack(e,t){const n=[];if(!e||0===e.length)return n.push("üìö Call Stack: (empty)"),n;const a=e.length,s=Math.min(a,t),o=a>t;n.push(`üìö Call Stack (${s}/${a}):`);for(let t=0;t<s;t++){const a=e[t],s=a.functionName||"(anonymous)",o=a.url||"(unknown)",i=a.location.lineNumber+1;n.push(`   ${t}: ${s} at ${o}:${i}`)}return o&&n.push(`   ... ${a-t} more frames`),n}export async function getCompactLocalVariables(t,n,a,s){const o=[];let i=0;const r=[],p=n.filter(e=>"local"===e.type);for(const n of p)if(n.object.objectId)try{const e=(await t.send("Runtime.getProperties",{objectId:n.object.objectId,ownProperties:!0,generatePreview:!0})).result||[];i+=e.length;for(const t of e){if(r.length>=a)break;if(t.value){const{formatted:e,type:n}=x(t.value,s);r.push({name:t.name,type:n,value:e})}else t.get&&r.push({name:t.name,type:"getter",value:"[getter]"})}}catch(t){const n=t instanceof Error?t.message:String(t);e(`[debugger] Failed to retrieve local variables: ${n}`)}if(0===r.length&&0===i)o.push("üì¶ Local Variables: (none)");else{o.push(`üì¶ Local Variables (${r.length}/${i}):`);for(const e of r)o.push(`   ${e.name}: (${e.type}) ${e.value}`)}return{lines:o,totalCount:i}}export async function getCompactCodeContext(t,n,a,o,i,r){const p=[];if(0===i)return p;try{const e=await h(t,n);if(null===e)return p.push("üìÑ Code: (source unavailable)"),p;const r=s(e,{lineNumber:a+1,columnNumber:o,contextLines:i,formatMinified:!1,maxLineLength:200});if(0===r.lines.length)return p.push("üìÑ Code: (no context available)"),p;p.push("üìÑ Code:");for(const e of r.lines){const t=e.isCurrentLine?" ‚ñ∂":"  ",n=String(e.displayLineNumber).padStart(4," ");p.push(`${t}${n} | ${e.content}`)}}catch(t){const n=t instanceof Error?t.message:String(t);p.push(`üìÑ Code: (error: ${n})`),e(`[debugger] Failed to get code context: ${n}`)}return p}export async function getCompactDebugStatus(e,t,n,a=0){const s=[];if(!n.showStatus)return s;if(!t.isPaused||!t.pausedCallFrames||0===t.pausedCallFrames.length)return s.push("‚ö†Ô∏è Debugger is not currently paused."),s;const o=t.pausedCallFrames,i=o[a];if(!i)return s.push(`‚ö†Ô∏è Invalid frame index: ${a}`),s;const r=i.functionName||"(anonymous)",p=i.url||"(unknown)",l=i.location.lineNumber+1,c=i.location.columnNumber??0;s.push(`üìç Location: ${r} at ${p}:${l}:${c}`);const u=getCompactCallStack(o,n.maxCallStackDepth);s.push(...u),s.push("");const d=await getCompactCodeContext(e,i.location.scriptId,i.location.lineNumber,i.location.columnNumber??0,n.contextLines,i.url);s.push(...d),s.push("");const{lines:m}=await getCompactLocalVariables(e,i.scopeChain,n.maxLocalVariables,n.maxValueLength);return s.push(...m),s.push(""),s.push("‚ÑπÔ∏è Use get_debugger_status or get_scope_variables for full details."),s}export async function waitForPausedEvent(e,t,n=5e3){return new Promise(t=>{let a,s=!1;const o=e=>{if(s)return;s=!0,clearTimeout(a),r();const n=e.reason||"step";t({paused:!0,reason:n})},i=()=>{s||(s=!0,clearTimeout(a),r(),t({paused:!1,reason:"resumed"}))},r=()=>{e.off("Debugger.paused",o),e.off("Debugger.resumed",i)};a=setTimeout(()=>{s||(s=!0,r(),t({paused:!1,reason:"timeout"}))},n),e.on("Debugger.paused",o),e.on("Debugger.resumed",i)})}export function formatPreview(e){if(!e)return"[no preview]";if("object"===e.type){const t=e.properties||[];if(0===t.length)return"array"===e.subtype?"[]":"{}";const n=t.slice(0,3).map(e=>`${e.name}: ${e.value??e.type}`).join(", ");return"array"===e.subtype?e.overflow?`[${n}, ...]`:`[${n}]`:e.overflow?`{${n}, ...}`:`{${n}}`}return e.description||String(e.value??"[unknown]")}export async function inspectScopeVariablesOptimized(t,n,a){const s=[];let o=!1;if(a.skipScopeVariables)return s.push("   [Scope inspection skipped - use get_scope_variables for details]"),{lines:s,hasTruncatedValues:!1};const i=n.map(async n=>{if("global"===n.type)return{scopeName:"global",lines:["   [global] (use get_scope_variables to inspect)"],hasTruncatedValues:!1};const s=n.name?`${n.type}: ${n.name}`:n.type,o=[`   [${s}]`];let i=!1;if(!n.object.objectId)return o.push("      (no properties)"),{scopeName:s,lines:o,hasTruncatedValues:!1};try{const e=(await t.send("Runtime.getProperties",{objectId:n.object.objectId,ownProperties:!0,generatePreview:!0})).result||[],s=e.slice(0,a.maxPropertiesPerScope),r=e.length>a.maxPropertiesPerScope;for(const e of s)if(e.value)if(a.useObjectPreviews&&e.value.preview){const t=formatPreview(e.value.preview),n=e.value.subtype||e.value.type;o.push(`      ${e.name}: (${n}) ${t}`),e.value.preview.overflow&&(i=!0)}else{const{formatted:t,truncated:n,type:s}=x(e.value,a.maxLineLength);i=i||n;const r=n?" [truncated]":"";o.push(`      ${e.name}: (${s}) ${t}${r}`)}else e.get&&o.push(`      ${e.name}: [getter]`);r&&(o.push(`      ... and ${e.length-a.maxPropertiesPerScope} more properties`),i=!0)}catch(t){const n=t instanceof Error?t.message:String(t);o.push(`      (unable to retrieve properties: ${n})`),e(`[debugger] Failed to retrieve properties for scope ${s}: ${t}`)}return{scopeName:s,lines:o,hasTruncatedValues:i}}),r=await Promise.all(i);for(const e of r)s.push(...e.lines),o=o||e.hasTruncatedValues;return{lines:s,hasTruncatedValues:o}}export const setBreakpoint=L({name:"set_breakpoint",description:"Set a JavaScript breakpoint at a specific line in a file matching a URL pattern. Supports smart snapping for minified code. Returns the CDP breakpoint ID which can be used to remove the breakpoint later.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{urlRegex:t.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:t.number().int().positive().describe("The line number to set the breakpoint at (1-based, as shown in editors)."),columnNumber:t.number().int().nonnegative().optional().describe("Optional target column number (0-based) for smart snapping. When specified, the tool will find the nearest valid breakpoint position within snapRange of this column."),snapRange:t.number().int().positive().optional().describe("Search range around the target column for finding valid breakpoint positions. Defaults to 100."),condition:t.string().optional().describe("Optional JavaScript expression. The breakpoint only triggers when this evaluates to true.")},handler:async(e,t,n)=>{const{urlRegex:a,lineNumber:s,columnNumber:o,snapRange:i=100,condition:p}=e.params,c=n.getSelectedPage(),u=await r(c);if(void 0!==o&&o<0)return t.appendResponseLine(`‚ùå Invalid column number: ${o}`),t.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),t.appendResponseLine(""),t.appendResponseLine("üí° Suggestions:"),t.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid column positions"),void t.appendResponseLine("   ‚Ä¢ Column 0 represents the start of the line");const d=s-1,h=o??0;let v=h,L=!1;if(void 0!==o){const e=await m(u,a);if(0===e.length)return t.appendResponseLine(`‚ùå Failed to set breakpoint: No scripts found matching pattern "${a}"`),t.appendResponseLine(`   Requested position: line ${s}, column ${o}`),t.appendResponseLine(""),t.appendResponseLine("üí° Suggestions:"),t.appendResponseLine("   ‚Ä¢ Verify the script is loaded in the page"),t.appendResponseLine("   ‚Ä¢ Check that the URL pattern is correct (use regex syntax)"),void t.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations");const n=Math.max(0,h-i),r=h+i;let p=[];for(const t of e){const e=await b(u,t.scriptId,d,n,d,r,t.url);p=p.concat(e)}if(0===p.length)return t.appendResponseLine("‚ùå Failed to set breakpoint: No valid breakpoint positions found"),t.appendResponseLine(`   Requested position: line ${s}, column ${o}`),t.appendResponseLine(`   Search range: columns ${n} - ${r}`),t.appendResponseLine(""),t.appendResponseLine("üí° Suggestions:"),t.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations on this line"),t.appendResponseLine(`   ‚Ä¢ Try increasing snapRange (currently ${i}) to search a wider area`),void t.appendResponseLine("   ‚Ä¢ Verify the line number contains executable code");const l=g(p,h);l&&(v=l.columnNumber,L=v!==h)}const x={lineNumber:d,urlRegex:a,columnNumber:v};p&&(x.condition=p);try{const e=await u.send("Debugger.setBreakpointByUrl",x),n=e.breakpointId,i=e.locations;if(i&&i.length>0){l(c,n);const e=i[0],r=e.lineNumber+1,d=e.columnNumber,m=L||r!==s||d!==v;t.appendResponseLine("‚úÖ Breakpoint set successfully"),t.appendResponseLine(`   Breakpoint ID: ${n}`),m&&t.appendResponseLine("‚ö° Snapped to nearest valid position"),t.appendResponseLine(`   URL pattern: ${a}`),void 0!==o?(t.appendResponseLine(`   Requested: line ${s}, column ${o}`),t.appendResponseLine(`   Resolved:  line ${r}, column ${d}`)):(t.appendResponseLine(`   Line: ${s}`),r!==s&&t.appendResponseLine(`   Resolved line: ${r}`)),p&&t.appendResponseLine(`   Condition: ${p}`),t.appendResponseLine(""),t.appendResponseLine("üìç Resolved locations:");for(const e of i){const n=f(u).get(e.scriptId),a=n?.url||`Script ${e.scriptId}`;t.appendResponseLine(`   ${a}:${e.lineNumber+1}:${e.columnNumber}`)}t.appendResponseLine(""),t.appendResponseLine("üí° Use this breakpoint ID with remove_breakpoint to delete it.")}else await u.send("Debugger.removeBreakpoint",{breakpointId:n}),t.appendResponseLine("‚ùå Failed to set breakpoint: No matching scripts found"),t.appendResponseLine(`   URL pattern: ${a}`),t.appendResponseLine(`   Line: ${s}`),t.appendResponseLine(""),t.appendResponseLine("üí° Suggestions:"),t.appendResponseLine("   ‚Ä¢ Verify the URL pattern matches a loaded script"),t.appendResponseLine("   ‚Ä¢ Check that the line number contains executable code"),t.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations")}catch(e){t.appendResponseLine(`‚ùå Failed to set breakpoint: ${e instanceof Error?e.message:String(e)}`),t.appendResponseLine(`   URL pattern: ${a}`),t.appendResponseLine(`   Line: ${s}`),void 0!==o&&t.appendResponseLine(`   Column: ${o}`),t.appendResponseLine(""),t.appendResponseLine("üí° Suggestions:"),t.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations"),t.appendResponseLine("   ‚Ä¢ Verify the script is loaded and the URL pattern is correct")}}});export const removeBreakpoint=L({name:"remove_breakpoint",description:"Remove a previously set JavaScript breakpoint by its CDP breakpoint ID.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:t.string().describe("The CDP breakpoint ID to remove (returned by set_breakpoint or list_breakpoints).")},handler:async(e,t,a)=>{const{breakpointId:s}=e.params,o=a.getSelectedPage(),i=await n(o);try{await i.send("Debugger.removeBreakpoint",{breakpointId:s}),c(o,s),t.appendResponseLine(`‚úÖ Removed breakpoint "${s}"`)}catch(e){c(o,s),t.appendResponseLine(`‚ö†Ô∏è Breakpoint "${s}" not found or already removed.`)}}});export const listBreakpoints=L({name:"list_breakpoints",description:"List all active JavaScript breakpoints on the current page. Retrieves breakpoints directly from CDP. Supports pagination and search.",annotations:{category:v.DEBUGGING,readOnlyHint:!0},schema:{searchTerm:t.string().optional().describe("Search term to filter breakpoints by ID or URL pattern (case-insensitive)."),pageSize:t.number().int().positive().optional().describe("Maximum number of breakpoints to return per page."),pageIdx:t.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,t,n)=>{const{searchTerm:a,pageSize:s,pageIdx:o}=e.params,i=n.getSelectedPage();let r=await p(i);if(0===r.length)return void t.appendResponseLine("No active breakpoints.");if(a){const e=a.toLowerCase();if(r=r.filter(t=>t.breakpointId.toLowerCase().includes(e)||t.url.toLowerCase().includes(e)),0===r.length)return void t.appendResponseLine(`No breakpoints matching "${a}" found.`)}const l=d(r,{pageSize:s,pageIdx:o});t.appendResponseLine(`Active breakpoints (${r.length} total):`),l.totalPages>1&&(t.appendResponseLine(`Showing ${l.startIndex+1}-${l.endIndex} (Page ${l.currentPage+1} of ${l.totalPages})`),l.hasNextPage&&t.appendResponseLine(`Next page: pageIdx=${l.currentPage+1}`)),t.appendResponseLine("");for(const e of l.items)t.appendResponseLine(`üìç ${e.breakpointId}`),t.appendResponseLine(`   URL pattern: ${e.url}`),t.appendResponseLine(`   Line: ${e.lineNumber}, Column: ${e.columnNumber}`),e.condition&&t.appendResponseLine(`   Condition: ${e.condition}`),t.appendResponseLine("")}});export const clearAllBreakpoints=L({name:"clear_all_breakpoints",description:"Remove all active JavaScript breakpoints on the current page. If the debugger is currently paused at a breakpoint, execution will be automatically resumed.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,t,a)=>{const s=a.getSelectedPage(),o=i(s),r=await n(s);if(o.isPaused)try{await r.send("Debugger.resume"),o.isPaused=!1,o.pausedCallFrames=void 0,t.appendResponseLine("‚ñ∂Ô∏è Resumed paused execution.")}catch(e){t.appendResponseLine(`‚ö†Ô∏è Failed to resume execution: ${e instanceof Error?e.message:String(e)}`)}const l=await p(s),c=l.length,d=[];for(const e of l)try{await r.send("Debugger.removeBreakpoint",{breakpointId:e.breakpointId})}catch(t){d.push(`${e.breakpointId}: ${t instanceof Error?t.message:String(t)}`)}if(u(s),d.length>0){t.appendResponseLine(`‚ö†Ô∏è Cleared ${c-d.length}/${c} breakpoints.`),t.appendResponseLine("Errors:");for(const e of d)t.appendResponseLine(`   ${e}`)}else t.appendResponseLine(`‚úÖ Cleared ${c} breakpoint(s).`)}});export const resumeExecution=L({name:"resume_execution",description:"Resume JavaScript execution after hitting a breakpoint.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,t,a)=>{const s=a.getSelectedPage(),o=i(s);if(!o.isPaused)return void t.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const r=await n(s);try{await r.send("Debugger.resume"),o.isPaused=!1,o.pausedCallFrames=void 0,t.appendResponseLine("‚úÖ Execution resumed.")}catch(e){t.appendResponseLine(`‚ùå Failed to resume: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOver=L({name:"step_over",description:"Step over to the next line of code without stepping into function calls. Automatically displays a compact debug status after stepping, including: call stack (max 4 frames), code context (2 lines before/after), and local variables (max 5). Use optional parameters to customize output: maxCallStackDepth, contextLines, maxLocalVariables, showStatus. Set showStatus=false to disable automatic status display.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{maxCallStackDepth:t.number().int().positive().default(4).optional().describe("Maximum call stack frames to display. Default is 4."),contextLines:t.number().int().nonnegative().default(2).optional().describe("Lines of code context before/after current line. Default is 2."),maxLocalVariables:t.number().int().positive().default(5).optional().describe("Maximum local variables to display. Default is 5."),showStatus:t.boolean().default(!0).optional().describe("Whether to show debug status after stepping. Default is true.")},handler:async(e,t,a)=>{const{maxCallStackDepth:s=DEFAULT_COMPACT_DEBUG_CONFIG.maxCallStackDepth,contextLines:o=DEFAULT_COMPACT_DEBUG_CONFIG.contextLines,maxLocalVariables:r=DEFAULT_COMPACT_DEBUG_CONFIG.maxLocalVariables,showStatus:p=DEFAULT_COMPACT_DEBUG_CONFIG.showStatus}=e.params,l=a.getSelectedPage(),c=i(l);if(!c.isPaused)return void t.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const u=await n(l);try{await u.send("Debugger.stepOver"),t.appendResponseLine("‚úÖ Stepped over to next line.");const e=await waitForPausedEvent(u,c);if(e.paused&&p){t.appendResponseLine("");const e={maxCallStackDepth:s,contextLines:o,maxLocalVariables:r,maxValueLength:DEFAULT_COMPACT_DEBUG_CONFIG.maxValueLength,showStatus:p},n=await getCompactDebugStatus(u,c,e);for(const e of n)t.appendResponseLine(e)}else e.paused||("timeout"===e.reason?(t.appendResponseLine(""),t.appendResponseLine("‚ö†Ô∏è Execution continued (no pause within timeout)")):"resumed"===e.reason&&(t.appendResponseLine(""),t.appendResponseLine("‚ÑπÔ∏è Execution has finished.")))}catch(e){t.appendResponseLine(`‚ùå Failed to step over: ${e instanceof Error?e.message:String(e)}`)}}});export const stepInto=L({name:"step_into",description:"Step into a function call at the current line. Automatically displays a compact debug status after stepping, including: call stack (max 4 frames), code context (2 lines before/after), and local variables (max 5). Use optional parameters to customize output: maxCallStackDepth, contextLines, maxLocalVariables, showStatus. Set showStatus=false to disable automatic status display.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{maxCallStackDepth:t.number().int().positive().default(4).optional().describe("Maximum call stack frames to display. Default is 4."),contextLines:t.number().int().nonnegative().default(2).optional().describe("Lines of code context before/after current line. Default is 2."),maxLocalVariables:t.number().int().positive().default(5).optional().describe("Maximum local variables to display. Default is 5."),showStatus:t.boolean().default(!0).optional().describe("Whether to show debug status after stepping. Default is true.")},handler:async(e,t,a)=>{const{maxCallStackDepth:s=DEFAULT_COMPACT_DEBUG_CONFIG.maxCallStackDepth,contextLines:o=DEFAULT_COMPACT_DEBUG_CONFIG.contextLines,maxLocalVariables:r=DEFAULT_COMPACT_DEBUG_CONFIG.maxLocalVariables,showStatus:p=DEFAULT_COMPACT_DEBUG_CONFIG.showStatus}=e.params,l=a.getSelectedPage(),c=i(l);if(!c.isPaused)return void t.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const u=await n(l);try{await u.send("Debugger.stepInto"),t.appendResponseLine("‚úÖ Stepped into function.");const e=await waitForPausedEvent(u,c);if(e.paused&&p){t.appendResponseLine("");const e={maxCallStackDepth:s,contextLines:o,maxLocalVariables:r,maxValueLength:DEFAULT_COMPACT_DEBUG_CONFIG.maxValueLength,showStatus:p},n=await getCompactDebugStatus(u,c,e);for(const e of n)t.appendResponseLine(e)}else e.paused||("timeout"===e.reason?(t.appendResponseLine(""),t.appendResponseLine("‚ö†Ô∏è Execution continued (no pause within timeout)")):"resumed"===e.reason&&(t.appendResponseLine(""),t.appendResponseLine("‚ÑπÔ∏è Execution has finished.")))}catch(e){t.appendResponseLine(`‚ùå Failed to step into: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOut=L({name:"step_out",description:"Step out of the current function to return to the caller. Automatically displays a compact debug status after stepping, including: call stack (max 4 frames), code context (2 lines before/after), and local variables (max 5). Use optional parameters to customize output: maxCallStackDepth, contextLines, maxLocalVariables, showStatus. Set showStatus=false to disable automatic status display.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{maxCallStackDepth:t.number().int().positive().default(4).optional().describe("Maximum call stack frames to display. Default is 4."),contextLines:t.number().int().nonnegative().default(2).optional().describe("Lines of code context before/after current line. Default is 2."),maxLocalVariables:t.number().int().positive().default(5).optional().describe("Maximum local variables to display. Default is 5."),showStatus:t.boolean().default(!0).optional().describe("Whether to show debug status after stepping. Default is true.")},handler:async(e,t,a)=>{const{maxCallStackDepth:s=DEFAULT_COMPACT_DEBUG_CONFIG.maxCallStackDepth,contextLines:o=DEFAULT_COMPACT_DEBUG_CONFIG.contextLines,maxLocalVariables:r=DEFAULT_COMPACT_DEBUG_CONFIG.maxLocalVariables,showStatus:p=DEFAULT_COMPACT_DEBUG_CONFIG.showStatus}=e.params,l=a.getSelectedPage(),c=i(l);if(!c.isPaused)return void t.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const u=await n(l);try{await u.send("Debugger.stepOut"),t.appendResponseLine("‚úÖ Stepped out of function.");const e=await waitForPausedEvent(u,c);if(e.paused&&p){t.appendResponseLine("");const e={maxCallStackDepth:s,contextLines:o,maxLocalVariables:r,maxValueLength:DEFAULT_COMPACT_DEBUG_CONFIG.maxValueLength,showStatus:p},n=await getCompactDebugStatus(u,c,e);for(const e of n)t.appendResponseLine(e)}else e.paused||("timeout"===e.reason?(t.appendResponseLine(""),t.appendResponseLine("‚ö†Ô∏è Execution continued (no pause within timeout)")):"resumed"===e.reason&&(t.appendResponseLine(""),t.appendResponseLine("‚ÑπÔ∏è Execution has finished.")))}catch(e){t.appendResponseLine(`‚ùå Failed to step out: ${e instanceof Error?e.message:String(e)}`)}}});export const getDebuggerStatus=L({name:"get_debugger_status",description:"Get the current status of the JavaScript debugger including call stack, code context, and scope variables.",annotations:{category:v.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:t.number().int().nonnegative().default(0).optional().describe("The call frame index to show variables for (0 = current frame). Default is 0."),contextLines:t.number().int().nonnegative().default(5).optional().describe("Number of lines to show before and after the current line. Set to 0 to disable code context. Default is 5."),maxPropertiesPerScope:t.number().int().positive().optional().describe("Maximum number of properties to show per scope. Default is 10."),skipScopeVariables:t.boolean().optional().describe("Skip scope variable inspection entirely for faster execution. Default is false."),useObjectPreviews:t.boolean().optional().describe("Use object preview data instead of fetching full properties. Default is true."),maxOutputLines:t.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated."),maxCallStackFrames:t.number().int().positive().default(20).optional().describe("Maximum number of call stack frames to display. Default is 20."),maxLineLength:t.number().int().positive().default(500).optional().describe("Maximum length of a single code line or variable value. Default is 500.")},handler:async(t,r,p)=>{const l=p.getSelectedPage(),c=i(l),u=t.params.frameIndex??0,d=t.params.contextLines??5,m=t.params.maxOutputLines??100,g=t.params.maxCallStackFrames??20,b=t.params.maxLineLength??500,f=a().maxBodySize,v={maxPropertiesPerScope:t.params.maxPropertiesPerScope??a().debugger.maxPropertiesPerScope,skipScopeVariables:t.params.skipScopeVariables??a().debugger.skipScopeVariables,useObjectPreviews:t.params.useObjectPreviews??a().debugger.useObjectPreviews,maxObjectDepth:a().debugger.maxObjectDepth,maxLineLength:b},L=[];let x=!1,R=0;const y=e=>{if(x)return!1;if(L.length>=m||R>=f)return x=!0,!1;let t=e;return e.length>b&&(t=e.substring(0,b)+"... [line truncated]"),R+t.length>f&&(t=t.substring(0,f-R)+"... [total size truncated]",x=!0),L.push(t),R+=t.length+1,!x},$=e=>{for(const t of e)if(!y(t))return!1;return!0},S=c.activeBreakpointIds.size;if(y("üîç Debugger Status:"),y("   Enabled: "+(c.enabled?"Yes":"No")),y("   Paused: "+(c.isPaused?"Yes":"No")),y(`   Active breakpoints: ${S}`),c.isPaused&&c.pausedCallFrames){if(u>=c.pausedCallFrames.length){y(""),y(`‚ùå Invalid frame index: ${u}`),y("   Valid range: 0-"+(c.pausedCallFrames.length-1));for(const e of L)r.appendResponseLine(e);return}y(""),y("üìö Call Stack:");const t=c.pausedCallFrames.length,a=Math.min(t,g),i=t>g;for(let e=0;e<a&&!x;e++){const t=c.pausedCallFrames[e],n=e===u?" ‚ñ∂":"";y(`   ${e}: ${t.functionName} at ${t.url||"(unknown)"}:${t.location.lineNumber+1}:${t.location.columnNumber??0}${n}`)}i&&!x&&y(`   ... and ${t-g} more frames`);const p=c.pausedCallFrames[u],m=await n(l);if(d>0&&!x){y("");try{const e=await h(m,p.location.scriptId);if(null===e)y(`‚ö†Ô∏è Source unavailable for script ${p.location.scriptId}`),y("   The script source could not be retrieved from the browser.");else{const t=s(e,{lineNumber:p.location.lineNumber+1,columnNumber:p.location.columnNumber??0,contextLines:d,formatMinified:!1,maxLineLength:b}),n=o(t,p.location.lineNumber+1,p.location.columnNumber??0,p.url,p.functionName);$(n.split("\n"))}}catch(t){const n=t instanceof Error?t.message:String(t);y(`‚ö†Ô∏è Failed to retrieve code context: ${n}`),e(`[debugger] Error retrieving code context for script ${p.location.scriptId}: ${t}`)}}if(!x){y(""),y(`üì¶ Scope Variables (frame ${u}: ${p.functionName}):`);try{const{lines:e,hasTruncatedValues:t}=await inspectScopeVariablesOptimized(m,p.scopeChain,v);$(e),t&&!x&&(y(""),y("‚ÑπÔ∏è  Some values are truncated. Use get_scope_variables for full details or save_scope_variables to save to file."))}catch(t){const n=t instanceof Error?t.message:String(t);y(`   ‚ö†Ô∏è Failed to inspect scope variables: ${n}`),y("   Use get_scope_variables for detailed inspection."),e(`[debugger] Error inspecting scope variables: ${t}`)}}}for(const e of L)r.appendResponseLine(e);x&&(r.appendResponseLine(""),r.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${m} lines.`),r.appendResponseLine("   Use get_scope_variables for detailed variable inspection."),r.appendResponseLine(`   Increase maxOutputLines parameter to see more (current: ${m}).`))}});export const evaluateOnCallFrame=L({name:"evaluate_on_call_frame",description:"Evaluate a JavaScript expression in the context of a specific call frame when paused.",annotations:{category:v.DEBUGGING,readOnlyHint:!0},schema:{expression:t.string().describe("The JavaScript expression to evaluate."),frameIndex:t.number().int().nonnegative().default(0).describe("The index of the call frame to evaluate in (0 = current frame).")},handler:async(e,t,a)=>{const{expression:s,frameIndex:o}=e.params,r=a.getSelectedPage(),p=i(r);if(!p.isPaused)return void t.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!p.pausedCallFrames||o>=p.pausedCallFrames.length)return void t.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((p.pausedCallFrames?.length??1)-1));const l=p.pausedCallFrames[o],c=await n(r);try{const e=await c.send("Debugger.evaluateOnCallFrame",{callFrameId:l.callFrameId,expression:s,returnByValue:!0});e.exceptionDetails?(t.appendResponseLine("‚ùå Evaluation error:"),t.appendResponseLine(`   ${e.exceptionDetails.exception?.description||e.exceptionDetails.text}`)):(t.appendResponseLine(`‚úÖ Result (frame ${o}: ${l.functionName}):`),t.appendResponseLine("```json"),t.appendResponseLine(JSON.stringify(e.result?.value??e.result,null,2)),t.appendResponseLine("```"))}catch(e){t.appendResponseLine(`‚ùå Failed to evaluate: ${e instanceof Error?e.message:String(e)}`)}}});export const getScopeVariables=L({name:"get_scope_variables",description:"Get detailed variable information from a specific scope when paused at a breakpoint. Supports pagination and search.",annotations:{category:v.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:t.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),scopeType:t.enum(["local","closure","block","script","global","catch","with","module","wasm-expression-stack"]).optional().describe("Filter to a specific scope type. If omitted, shows all scopes."),variableName:t.string().optional().describe("Specific variable name to inspect in detail. If omitted, shows all variables."),searchTerm:t.string().optional().describe("Search term to filter variable names (case-insensitive substring match)."),pageSize:t.number().int().positive().optional().describe("Maximum number of variables to return per page. When omitted, uses default page size."),pageIdx:t.number().int().min(0).optional().describe("Page number to return (0-based). When omitted, returns the first page."),maxDepth:t.number().int().positive().default(3).optional().describe("Maximum depth for nested object inspection. Default is 3."),maxOutputLines:t.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated with a hint to use saveToFile."),saveToFile:t.string().optional().describe("Optional file path to save full output. When provided, saves complete output to file without truncation."),maxLineLength:t.number().int().positive().default(1e3).optional().describe("Maximum length of a single variable value or output line. Default is 1000.")},handler:async(e,t,s)=>{const{frameIndex:o,scopeType:r,variableName:p,searchTerm:l,pageSize:c,pageIdx:u,maxDepth:m,maxOutputLines:g,saveToFile:b,maxLineLength:f=1e3}=e.params,h=s.getSelectedPage(),v=i(h),L=a().maxBodySize;if(!v.isPaused)return void t.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!v.pausedCallFrames||o>=v.pausedCallFrames.length)return void t.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((v.pausedCallFrames?.length??1)-1));const R=v.pausedCallFrames[o],y=await n(h),$=[],S=g??100;let C=0;const w=e=>{$.push(e),C+=e.length+1};async function D(e,t,n){const a=[];if(t<=0)return a.push(`${n}[max depth reached]`),a;try{const s=(await y.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;if("object"===s.type&&s.objectId&&"null"!==s.subtype){a.push(`${n}${e.name}: (${s.subtype||s.type}) ${s.description||""}`);const o=await D(s.objectId,t-1,n+"  ");a.push(...o)}else{const{formatted:t,type:o}=x(s,f);a.push(`${n}${e.name}: (${o}) ${t}`)}}else e.get&&a.push(`${n}${e.name}: [getter]`)}catch(e){const t=e instanceof Error?e.message:String(e);a.push(`${n}(unable to retrieve properties: ${t})`)}return a}w(`üì¶ Scope Variables (frame ${o}: ${R.functionName}):`),w("");for(const e of R.scopeChain){if(r&&e.type!==r)continue;if(w(`=== [${e.name?`${e.type}: ${e.name}`:e.type}] ===`),e.object.objectId){try{let t=(await y.send("Runtime.getProperties",{objectId:e.object.objectId,ownProperties:!0,generatePreview:!0})).result||[];if(p){const e=t.find(e=>e.name===p);if(e){if(w(`Variable: ${p}`),e.value){const t=e.value;if("object"===t.type&&t.objectId&&"null"!==t.subtype){w(`Type: ${t.subtype||t.type}`),w(`Description: ${t.description||"N/A"}`),w("Properties:");const e=await D(t.objectId,m??3,"   ");for(const t of e)w(t)}else{const{formatted:e,type:n}=x(t,f);w(`Type: ${n}`),w(`Value: ${e}`)}}}else w(`   Variable "${p}" not found in this scope.`)}else{if(l){const e=l.toLowerCase();if(t=t.filter(t=>t.name.toLowerCase().includes(e)),0===t.length){w(`   No variables matching "${l}" found.`),w("");continue}}const e=d(t,{pageSize:c,pageIdx:u});e.totalPages>1&&(w(`Showing ${e.startIndex+1}-${e.endIndex} of ${t.length} variables (Page ${e.currentPage+1} of ${e.totalPages})`),e.hasNextPage&&w(`Next page: pageIdx=${e.currentPage+1}`),e.hasPreviousPage&&w("Previous page: pageIdx="+(e.currentPage-1)));for(const t of e.items)if(t.value){const e=t.value;if("object"===e.type&&e.objectId&&"null"!==e.subtype){w(`${t.name}: (${e.subtype||e.type}) ${e.description||""}`);const n=await D(e.objectId,(m??3)-1,"   ");for(const e of n)w(e)}else{const{formatted:n,type:a}=x(e,f);w(`${t.name}: (${a}) ${n}`)}}else t.get&&w(`${t.name}: [getter]`)}}catch(e){w(`   (error retrieving properties: ${e instanceof Error?e.message:String(e)})`)}if(w(""),C>=L&&!b)break}else w("   (no properties)"),w("")}if(b){const e=$.join("\n");await s.saveFile((new TextEncoder).encode(e),b),t.appendResponseLine(`‚úÖ Full output saved to ${b} (${$.length} lines)`),t.appendResponseLine("")}let k=0,I=!1;for(let e=0;e<$.length;e++){const n=$[e];if(e>=S||k+n.length>L){I=!0;break}let a=n;n.length>f&&(a=n.substring(0,f)+"... [line truncated]"),t.appendResponseLine(a),k+=a.length+1}I&&(t.appendResponseLine(""),t.appendResponseLine("‚ö†Ô∏è Output truncated: showing first part of the result."),t.appendResponseLine("   Use saveToFile parameter to save full output, or increase maxOutputLines/maxLineLength."),b||t.appendResponseLine('   Example: get_scope_variables({ saveToFile: "/tmp/scope_vars.txt" })'))}});export const saveScopeVariables=L({name:"save_scope_variables",description:"Save all scope variables from the current debug context to a JSON file.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{filePath:t.string().describe("Absolute or relative file path to save the scope variables JSON."),frameIndex:t.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),maxDepth:t.number().int().positive().default(5).optional().describe("Maximum depth for nested object serialization. Default is 5."),includeGlobal:t.boolean().default(!1).optional().describe("Include global scope variables. Default is false (globals are very large).")},handler:async(e,t,a)=>{const{filePath:s,frameIndex:o,maxDepth:r,includeGlobal:p}=e.params,l=a.getSelectedPage(),c=i(l);if(!c.isPaused)return void t.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!c.pausedCallFrames||o>=c.pausedCallFrames.length)return void t.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((c.pausedCallFrames?.length??1)-1));const u=c.pausedCallFrames[o],d=await n(l);async function m(e,t,n){if(t<=0||n.has(e))return"[max depth or circular reference]";n.add(e);const a={};try{const s=(await d.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;"object"===s.type&&s.objectId&&"null"!==s.subtype?(s.subtype,a[e.name]=await m(s.objectId,t-1,n)):void 0!==s.value?a[e.name]=s.value:s.unserializableValue?a[e.name]=`[${s.unserializableValue}]`:a[e.name]=`[${s.subtype||s.type}]`}else e.get&&(a[e.name]="[getter]")}catch{return"[error serializing]"}return a}const g={frame:{index:o,functionName:u.functionName,url:u.url,location:{lineNumber:u.location.lineNumber+1,columnNumber:u.location.columnNumber??0}},scopes:{}};for(const e of u.scopeChain){if("global"===e.type&&!p){g.scopes[e.type]="[skipped - use includeGlobal:true to include]";continue}const t=e.name?`${e.type}:${e.name}`:e.type;e.object.objectId?g.scopes[t]=await m(e.object.objectId,r??5,new Set):g.scopes[t]={}}const b=JSON.stringify(g,null,2);await a.saveFile((new TextEncoder).encode(b),s),t.appendResponseLine(`‚úÖ Saved scope variables to ${s}`),t.appendResponseLine(`   Frame: ${u.functionName}`),t.appendResponseLine(`   Scopes saved: ${Object.keys(g.scopes).join(", ")}`)}});export const pauseOnExceptions=L({name:"pause_on_exceptions",description:"Configure whether the debugger should pause on exceptions (none, uncaught, or all).",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{state:t.enum(["none","uncaught","all"]).describe("When to pause on exceptions.")},handler:async(e,t,n)=>{const{state:a}=e.params,s=n.getSelectedPage(),o=await r(s);try{switch(await o.send("Debugger.setPauseOnExceptions",{state:a}),t.appendResponseLine(`‚úÖ Exception pausing set to: ${a}`),a){case"none":t.appendResponseLine("   Debugger will not pause on any exceptions.");break;case"uncaught":t.appendResponseLine("   Debugger will pause only on uncaught exceptions.");break;case"all":t.appendResponseLine("   Debugger will pause on all exceptions (caught and uncaught).")}}catch(e){t.appendResponseLine(`‚ùå Failed to set exception pausing: ${e instanceof Error?e.message:String(e)}`)}}});export const disableDebugger=L({name:"disable_debugger",description:"Disable the JavaScript debugger on the current page and remove all breakpoints.",annotations:{category:v.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,t,a)=>{const s=a.getSelectedPage(),o=i(s);if(!o.enabled)return void t.appendResponseLine("‚ÑπÔ∏è Debugger is already disabled.");const r=await n(s);try{await r.send("Debugger.disable"),o.enabled=!1,o.activeBreakpointIds.clear(),o.isPaused=!1,o.pausedCallFrames=void 0,t.appendResponseLine("‚úÖ Debugger disabled."),t.appendResponseLine("   All breakpoints have been removed.")}catch(e){t.appendResponseLine(`‚ùå Failed to disable debugger: ${e instanceof Error?e.message:String(e)}`)}}});export const getPossibleBreakpoints=L({name:"get_possible_breakpoints",description:"Discover all valid breakpoint locations in a script at a specific line. Useful for minified code.",annotations:{category:v.DEBUGGING,readOnlyHint:!0},schema:{urlRegex:t.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:t.number().int().positive().describe("The line number to search for breakpoints (1-based, as shown in editors)."),startColumn:t.number().int().nonnegative().optional().describe("Optional start column to filter results (0-based). Defaults to 0."),endColumn:t.number().int().nonnegative().optional().describe("Optional end column to filter results (0-based). Defaults to end of line."),maxCount:t.number().int().positive().optional().describe("Maximum number of locations to return. Defaults to 20.")},handler:async(e,t,n)=>{const{urlRegex:a,lineNumber:s,startColumn:o,endColumn:i,maxCount:p=20}=e.params,l=n.getSelectedPage(),c=await r(l);if(void 0!==o&&o<0)return t.appendResponseLine(`‚ùå Invalid startColumn: ${o}`),t.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),t.appendResponseLine(""),void t.appendResponseLine("üí° Suggestion: Use startColumn=0 to search from the beginning of the line.");if(void 0!==i&&i<0)return t.appendResponseLine(`‚ùå Invalid endColumn: ${i}`),t.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),t.appendResponseLine(""),void t.appendResponseLine("üí° Suggestion: Omit endColumn to search to the end of the line.");if(void 0!==o&&void 0!==i&&o>i)return t.appendResponseLine(`‚ùå Invalid column range: startColumn (${o}) > endColumn (${i})`),t.appendResponseLine("   startColumn must be less than or equal to endColumn."),t.appendResponseLine(""),void t.appendResponseLine("üí° Suggestion: Swap the values or adjust the range.");const u=s-1,d=await m(c,a);if(0===d.length)return t.appendResponseLine(`‚ùå No scripts found matching pattern: ${a}`),void t.appendResponseLine("   üí° Suggestion: Verify the script is loaded and the URL pattern is correct.");let g=[];for(const e of d){const t=o??0,n=i??t+100,a=(await b(c,e.scriptId,u,t,u,n,e.url)).filter(e=>!(void 0!==o&&e.columnNumber<o)&&!(void 0!==i&&e.columnNumber>i));g=g.concat(a)}if(0===g.length)return t.appendResponseLine(`‚ùå No valid breakpoint locations found at line ${s}`),void 0===o&&void 0===i||t.appendResponseLine(`   Column range: ${o??0} - ${i??"end"}`),void t.appendResponseLine("   üí° Suggestion: Try a different line or expand the column range.");g.sort((e,t)=>{const n=e.scriptUrl.localeCompare(t.scriptUrl);return 0!==n?n:e.columnNumber-t.columnNumber});const f=g.length,h=f>p,v=h?g.slice(0,p):g;t.appendResponseLine(`üìç Possible breakpoint locations at line ${s}:`),t.appendResponseLine(`   URL pattern: ${a}`),void 0===o&&void 0===i||t.appendResponseLine(`   Column range: ${o??0} - ${i??"end"}`),t.appendResponseLine("");for(const e of v)t.appendResponseLine(`   ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`);h?(t.appendResponseLine(""),t.appendResponseLine(`‚ö†Ô∏è Results truncated: showing ${p} of ${f} locations`),t.appendResponseLine("   üí° Suggestion: Use startColumn/endColumn to narrow the search range.")):(t.appendResponseLine(""),t.appendResponseLine(`Found ${f} valid breakpoint location(s).`))}});export async function ensureDebuggerEnabledForPage(e){await r(e)}
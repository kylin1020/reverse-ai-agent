/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as n}from"../third_party/index.js";import{getCdpSession as t}from"../utils/cdp.js";import{getConfig as a}from"../utils/config.js";import{paginate as s}from"../utils/pagination.js";import{clearParseResultCache as i}from"./analysis.js";import{ToolCategory as o}from"./categories.js";import{findMatchingScripts as r,findNearestBreakpointLocation as p,queryPossibleBreakpoints as l,cacheScript as c,clearScriptCache as d,getScriptCache as u,getScriptSource as m}from"../utils/smartBreakpointUtils.js";import{ScriptCacheRegistry as g}from"../utils/scriptCacheRegistry.js";import{defineTool as b}from"./ToolDefinition.js";import{extractContextCode as f,formatContextCodeOutput as h}from"../utils/contextCodeUtils.js";function v(e,n=a().maxInlineStringLength){const t=e.type||"unknown",s=e.subtype;if(void 0!==e.value){const s=function(e,n=a().maxInlineStringLength){if(void 0===e)return{formatted:"undefined",truncated:!1};if(null===e)return{formatted:"null",truncated:!1};let t;if("string"==typeof e)t=JSON.stringify(e);else if("object"==typeof e)try{t=JSON.stringify(e)}catch{t=String(e)}else t=String(e);return t.length>n?{formatted:t.substring(0,n)+"...",truncated:!0}:{formatted:t,truncated:!1}}(e.value,n);return{...s,type:t}}if(e.unserializableValue)return{formatted:e.unserializableValue,truncated:!1,type:t};if(e.preview){const a=e.preview;if(a.overflow){return{formatted:`{${(a.properties||[]).slice(0,5).map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}, ...}`,truncated:!0,type:s||t}}if(a.properties){const e=`{${a.properties.map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}}`;return e.length>n?{formatted:e.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:e,truncated:!1,type:s||t}}}if(e.description){const a=e.description;return a.length>n?{formatted:a.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:a,truncated:!1,type:s||t}}return{formatted:`[${s||t}]`,truncated:!1,type:s||t}}export function formatPreview(e){if(!e)return"[no preview]";if("object"===e.type){const n=e.properties||[];if(0===n.length)return"array"===e.subtype?"[]":"{}";const t=n.slice(0,3).map(e=>`${e.name}: ${e.value??e.type}`).join(", ");return"array"===e.subtype?e.overflow?`[${t}, ...]`:`[${t}]`:e.overflow?`{${t}, ...}`:`{${t}}`}return e.description||String(e.value??"[unknown]")}export async function inspectScopeVariablesOptimized(n,t,a){const s=[];let i=!1;if(a.skipScopeVariables)return s.push("   [Scope inspection skipped - use get_scope_variables for details]"),{lines:s,hasTruncatedValues:!1};const o=t.map(async t=>{if("global"===t.type)return{scopeName:"global",lines:["   [global] (use get_scope_variables to inspect)"],hasTruncatedValues:!1};const s=t.name?`${t.type}: ${t.name}`:t.type,i=[`   [${s}]`];let o=!1;if(!t.object.objectId)return i.push("      (no properties)"),{scopeName:s,lines:i,hasTruncatedValues:!1};try{const e=(await n.send("Runtime.getProperties",{objectId:t.object.objectId,ownProperties:!0,generatePreview:!0})).result||[],s=e.slice(0,a.maxPropertiesPerScope),r=e.length>a.maxPropertiesPerScope;for(const e of s)if(e.value)if(a.useObjectPreviews&&e.value.preview){const n=formatPreview(e.value.preview),t=e.value.subtype||e.value.type;i.push(`      ${e.name}: (${t}) ${n}`),e.value.preview.overflow&&(o=!0)}else{const{formatted:n,truncated:t,type:s}=v(e.value,a.maxLineLength);o=o||t;const r=t?" [truncated]":"";i.push(`      ${e.name}: (${s}) ${n}${r}`)}else e.get&&i.push(`      ${e.name}: [getter]`);r&&(i.push(`      ... and ${e.length-a.maxPropertiesPerScope} more properties`),o=!0)}catch(n){const t=n instanceof Error?n.message:String(n);i.push(`      (unable to retrieve properties: ${t})`),e(`[debugger] Failed to retrieve properties for scope ${s}: ${n}`)}return{scopeName:s,lines:i,hasTruncatedValues:o}}),r=await Promise.all(o);for(const e of r)s.push(...e.lines),i=i||e.hasTruncatedValues;return{lines:s,hasTruncatedValues:i}}const L=new WeakMap;function R(e){let n=L.get(e);return n||(n={enabled:!1,breakpoints:new Map,isPaused:!1},L.set(e,n)),n}const y=new WeakSet;async function $(n){const a=await t(n),s=R(n);if(s.enabled||(await a.send("Debugger.enable"),s.enabled=!0,a.on("Debugger.scriptParsed",async n=>{const t=n.scriptId,s=n.url||"";if(c(a,{scriptId:t,url:s,startLine:n.startLine,startColumn:n.startColumn,endLine:n.endLine,endColumn:n.endColumn}),s)try{const e=(await a.send("Debugger.getScriptSource",{scriptId:t})).scriptSource;if(e){const n=g.getOrCreate(a);await n.cacheScript(t,s,e)}}catch(n){e(`[debugger] Failed to cache script source for ${t}: ${n}`)}e(`[debugger] Script parsed: ${s||t}`)}),a.on("Debugger.paused",n=>{s.isPaused=!0,s.pausedCallFrames=n.callFrames?.map(e=>({callFrameId:e.callFrameId,functionName:e.functionName||"(anonymous)",location:{scriptId:e.location.scriptId,lineNumber:e.location.lineNumber,columnNumber:e.location.columnNumber},url:e.url||"",scopeChain:e.scopeChain?.map(e=>({type:e.type,object:{type:e.object?.type,objectId:e.object?.objectId},name:e.name}))||[]})),e("[debugger] Execution paused at breakpoint")}),a.on("Debugger.resumed",()=>{s.isPaused=!1,s.pausedCallFrames=void 0,e("[debugger] Execution resumed")})),!y.has(n)){let t;y.add(n);try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}a.on("Page.frameStartedLoading",async o=>{let r=!t||o.frameId===t;if(!r)try{const e=await a.send("Page.getFrameTree"),n=e.frameTree?.frame?.id;o.frameId===n&&(r=!0,t=n)}catch{r=!0}if(r){if(d(a),i(a),e("[debugger] Script cache and parse result cache cleared on navigation"),s.breakpoints.size>0){e("[debugger] Main frame started loading, restoring breakpoints immediately...");try{await async function(n,t){const a=R(n);try{await t.send("Emulation.setScriptExecutionDisabled",{value:!0}),e("[debugger] Script execution disabled temporarily")}catch{}try{await t.send("Debugger.enable")}catch{}for(const[n,s]of a.breakpoints)try{const a={lineNumber:s.resolvedLineNumber-1,urlRegex:s.urlPattern,columnNumber:s.resolvedColumnNumber};s.condition&&(a.condition=s.condition);const i=await t.send("Debugger.setBreakpointByUrl",a);s.breakpointId=i.breakpointId,e(`[debugger] Restored breakpoint "${n}" after navigation`)}catch(t){e(`[debugger] Failed to restore breakpoint "${n}": ${t}`)}try{await t.send("Emulation.setScriptExecutionDisabled",{value:!1}),e("[debugger] Script execution re-enabled")}catch{}}(n,a)}catch(n){e(`[debugger] Error restoring breakpoints: ${n}`)}}try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}}});try{await a.send("Page.enable")}catch{}}return a}export const setBreakpoint=b({name:"set_breakpoint",description:"Set a JavaScript breakpoint at a specific line in a file matching a URL pattern. Supports smart snapping for minified code.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("A unique identifier for this breakpoint (used to remove it later)."),urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to set the breakpoint at (1-based, as shown in editors)."),columnNumber:n.number().int().nonnegative().optional().describe("Optional target column number (0-based) for smart snapping. When specified, the tool will find the nearest valid breakpoint position within snapRange of this column."),snapRange:n.number().int().positive().optional().describe("Search range around the target column for finding valid breakpoint positions. Defaults to 100."),condition:n.string().optional().describe("Optional JavaScript expression. The breakpoint only triggers when this evaluates to true.")},handler:async(e,n,t)=>{const{breakpointId:a,urlRegex:s,lineNumber:i,columnNumber:o,snapRange:c=100,condition:d}=e.params,m=t.getSelectedPage(),g=await $(m),b=R(m);if(void 0!==o&&o<0)return n.appendResponseLine(`‚ùå Invalid column number: ${o}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid column positions"),void n.appendResponseLine("   ‚Ä¢ Column 0 represents the start of the line");const f=i-1,h=o??0;let v=h,L=!1;if(void 0!==o){const e=await r(g,s);if(0===e.length)return n.appendResponseLine(`‚ùå Failed to set breakpoint: No scripts found matching pattern "${s}"`),n.appendResponseLine(`   Requested position: line ${i}, column ${o}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded in the page"),n.appendResponseLine("   ‚Ä¢ Check that the URL pattern is correct (use regex syntax)"),void n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations");const t=Math.max(0,h-c),a=h+c;let d=[];for(const n of e){const e=await l(g,n.scriptId,f,t,f,a,n.url);d=d.concat(e)}if(0===d.length)return n.appendResponseLine("‚ùå Failed to set breakpoint: No valid breakpoint positions found"),n.appendResponseLine(`   Requested position: line ${i}, column ${o}`),n.appendResponseLine(`   Search range: columns ${t} - ${a}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations on this line"),n.appendResponseLine(`   ‚Ä¢ Try increasing snapRange (currently ${c}) to search a wider area`),void n.appendResponseLine("   ‚Ä¢ Verify the line number contains executable code");const u=p(d,h);u&&(v=u.columnNumber,L=v!==h)}const y={lineNumber:f,urlRegex:s,columnNumber:v};d&&(y.condition=d);try{const e=await g.send("Debugger.setBreakpointByUrl",y),t=e.locations;if(t&&t.length>0){const r=t[0],p=r.lineNumber+1,l=r.columnNumber,c=L||p!==i||l!==v,m={breakpointId:e.breakpointId,urlPattern:s,lineNumber:i,columnNumber:o,resolvedLineNumber:p,resolvedColumnNumber:l,condition:d,wasSnapped:c};b.breakpoints.set(a,m),n.appendResponseLine(`‚úÖ Breakpoint "${a}" set successfully`),c&&n.appendResponseLine("‚ö° Snapped to nearest valid position"),n.appendResponseLine(`   URL pattern: ${s}`),void 0!==o?(n.appendResponseLine(`   Requested: line ${i}, column ${o}`),n.appendResponseLine(`   Resolved:  line ${p}, column ${l}`)):(n.appendResponseLine(`   Line: ${i}`),p!==i&&n.appendResponseLine(`   Resolved line: ${p}`)),d&&n.appendResponseLine(`   Condition: ${d}`),n.appendResponseLine(`   CDP breakpoint ID: ${e.breakpointId}`),n.appendResponseLine(""),n.appendResponseLine("üìç Resolved locations:");for(const e of t){const t=u(g).get(e.scriptId),a=t?.url||`Script ${e.scriptId}`;n.appendResponseLine(`   ${a}:${e.lineNumber+1}:${e.columnNumber}`)}}else await g.send("Debugger.removeBreakpoint",{breakpointId:e.breakpointId}),n.appendResponseLine("‚ùå Failed to set breakpoint: No matching scripts found"),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${i}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the URL pattern matches a loaded script"),n.appendResponseLine("   ‚Ä¢ Check that the line number contains executable code"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations")}catch(e){n.appendResponseLine(`‚ùå Failed to set breakpoint: ${e instanceof Error?e.message:String(e)}`),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${i}`),void 0!==o&&n.appendResponseLine(`   Column: ${o}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded and the URL pattern is correct")}}});export const removeBreakpoint=b({name:"remove_breakpoint",description:"Remove a previously set JavaScript breakpoint by its ID.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("The ID of the breakpoint to remove (as specified when setting it).")},handler:async(e,n,a)=>{const{breakpointId:s}=e.params,i=a.getSelectedPage(),o=R(i),r=o.breakpoints.get(s);if(!r)return void n.appendResponseLine(`‚ö†Ô∏è Breakpoint "${s}" not found.`);const p=await t(i);try{await p.send("Debugger.removeBreakpoint",{breakpointId:r.breakpointId}),o.breakpoints.delete(s),n.appendResponseLine(`‚úÖ Removed breakpoint "${s}"`)}catch(e){n.appendResponseLine(`‚ùå Failed to remove breakpoint: ${e instanceof Error?e.message:String(e)}`)}}});export const listBreakpoints=b({name:"list_breakpoints",description:"List all active JavaScript breakpoints on the current page. Supports pagination and search.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{searchTerm:n.string().optional().describe("Search term to filter breakpoints by ID or URL pattern (case-insensitive)."),pageSize:n.number().int().positive().optional().describe("Maximum number of breakpoints to return per page."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,n,t)=>{const{searchTerm:a,pageSize:i,pageIdx:o}=e.params,r=R(t.getSelectedPage());if(0===r.breakpoints.size)return void n.appendResponseLine("No active breakpoints.");let p=Array.from(r.breakpoints.entries());if(a){const e=a.toLowerCase();if(p=p.filter(([n,t])=>n.toLowerCase().includes(e)||t.urlPattern.toLowerCase().includes(e)),0===p.length)return void n.appendResponseLine(`No breakpoints matching "${a}" found.`)}const l=s(p,{pageSize:i,pageIdx:o});n.appendResponseLine(`Active breakpoints (${p.length} total):`),l.totalPages>1&&(n.appendResponseLine(`Showing ${l.startIndex+1}-${l.endIndex} (Page ${l.currentPage+1} of ${l.totalPages})`),l.hasNextPage&&n.appendResponseLine(`Next page: pageIdx=${l.currentPage+1}`)),n.appendResponseLine("");for(const[e,t]of l.items)n.appendResponseLine(`üìç ${e}`),n.appendResponseLine(`   URL pattern: ${t.urlPattern}`),n.appendResponseLine(`   Line: ${t.lineNumber}`),void 0!==t.columnNumber&&n.appendResponseLine(`   Column: ${t.columnNumber}`),t.condition&&n.appendResponseLine(`   Condition: ${t.condition}`),n.appendResponseLine("")}});export const clearAllBreakpoints=b({name:"clear_all_breakpoints",description:"Remove all active JavaScript breakpoints on the current page.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=R(s),o=await t(s),r=i.breakpoints.size,p=[];for(const[e,n]of i.breakpoints)try{await o.send("Debugger.removeBreakpoint",{breakpointId:n.breakpointId})}catch(n){p.push(`${e}: ${n instanceof Error?n.message:String(n)}`)}if(i.breakpoints.clear(),p.length>0){n.appendResponseLine(`‚ö†Ô∏è Cleared ${r-p.length}/${r} breakpoints.`),n.appendResponseLine("Errors:");for(const e of p)n.appendResponseLine(`   ${e}`)}else n.appendResponseLine(`‚úÖ Cleared ${r} breakpoint(s).`)}});export const resumeExecution=b({name:"resume_execution",description:"Resume JavaScript execution after hitting a breakpoint.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=R(s);if(!i.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.resume"),i.isPaused=!1,i.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Execution resumed.")}catch(e){n.appendResponseLine(`‚ùå Failed to resume: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOver=b({name:"step_over",description:"Step over to the next line of code without stepping into function calls.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!R(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepOver"),n.appendResponseLine("‚úÖ Stepped over to next line.")}catch(e){n.appendResponseLine(`‚ùå Failed to step over: ${e instanceof Error?e.message:String(e)}`)}}});export const stepInto=b({name:"step_into",description:"Step into a function call at the current line.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!R(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepInto"),n.appendResponseLine("‚úÖ Stepped into function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step into: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOut=b({name:"step_out",description:"Step out of the current function to return to the caller.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!R(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepOut"),n.appendResponseLine("‚úÖ Stepped out of function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step out: ${e instanceof Error?e.message:String(e)}`)}}});export const getDebuggerStatus=b({name:"get_debugger_status",description:"Get the current status of the JavaScript debugger including call stack, code context, and scope variables.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).optional().describe("The call frame index to show variables for (0 = current frame). Default is 0."),contextLines:n.number().int().nonnegative().default(5).optional().describe("Number of lines to show before and after the current line. Set to 0 to disable code context. Default is 5."),maxPropertiesPerScope:n.number().int().positive().optional().describe("Maximum number of properties to show per scope. Default is 10."),skipScopeVariables:n.boolean().optional().describe("Skip scope variable inspection entirely for faster execution. Default is false."),useObjectPreviews:n.boolean().optional().describe("Use object preview data instead of fetching full properties. Default is true."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated."),maxCallStackFrames:n.number().int().positive().default(20).optional().describe("Maximum number of call stack frames to display. Default is 20."),maxLineLength:n.number().int().positive().default(500).optional().describe("Maximum length of a single code line or variable value. Default is 500.")},handler:async(n,s,i)=>{const o=i.getSelectedPage(),r=R(o),p=n.params.frameIndex??0,l=n.params.contextLines??5,c=n.params.maxOutputLines??100,d=n.params.maxCallStackFrames??20,u=n.params.maxLineLength??500,g=a().maxBodySize,b={maxPropertiesPerScope:n.params.maxPropertiesPerScope??a().debugger.maxPropertiesPerScope,skipScopeVariables:n.params.skipScopeVariables??a().debugger.skipScopeVariables,useObjectPreviews:n.params.useObjectPreviews??a().debugger.useObjectPreviews,maxObjectDepth:a().debugger.maxObjectDepth,maxLineLength:u},v=[];let L=!1,y=0;const $=e=>{if(L)return!1;if(v.length>=c||y>=g)return L=!0,!1;let n=e;return e.length>u&&(n=e.substring(0,u)+"... [line truncated]"),y+n.length>g&&(n=n.substring(0,g-y)+"... [total size truncated]",L=!0),v.push(n),y+=n.length+1,!L},x=e=>{for(const n of e)if(!$(n))return!1;return!0};if($("üîç Debugger Status:"),$("   Enabled: "+(r.enabled?"Yes":"No")),$("   Paused: "+(r.isPaused?"Yes":"No")),$(`   Active breakpoints: ${r.breakpoints.size}`),r.isPaused&&r.pausedCallFrames){if(p>=r.pausedCallFrames.length){$(""),$(`‚ùå Invalid frame index: ${p}`),$("   Valid range: 0-"+(r.pausedCallFrames.length-1));for(const e of v)s.appendResponseLine(e);return}$(""),$("üìö Call Stack:");const n=r.pausedCallFrames.length,a=Math.min(n,d),i=n>d;for(let e=0;e<a&&!L;e++){const n=r.pausedCallFrames[e],t=e===p?" ‚ñ∂":"";$(`   ${e}: ${n.functionName} at ${n.url||"(unknown)"}:${n.location.lineNumber+1}:${n.location.columnNumber??0}${t}`)}i&&!L&&$(`   ... and ${n-d} more frames`);const c=r.pausedCallFrames[p],g=await t(o);if(l>0&&!L){$("");try{const e=await m(g,c.location.scriptId);if(null===e)$(`‚ö†Ô∏è Source unavailable for script ${c.location.scriptId}`),$("   The script source could not be retrieved from the browser.");else{const n=f(e,{lineNumber:c.location.lineNumber+1,columnNumber:c.location.columnNumber??0,contextLines:l,formatMinified:!1,maxLineLength:u}),t=h(n,c.location.lineNumber+1,c.location.columnNumber??0,c.url,c.functionName);x(t.split("\n"))}}catch(n){const t=n instanceof Error?n.message:String(n);$(`‚ö†Ô∏è Failed to retrieve code context: ${t}`),e(`[debugger] Error retrieving code context for script ${c.location.scriptId}: ${n}`)}}if(!L){$(""),$(`üì¶ Scope Variables (frame ${p}: ${c.functionName}):`);try{const{lines:e,hasTruncatedValues:n}=await inspectScopeVariablesOptimized(g,c.scopeChain,b);x(e),n&&!L&&($(""),$("‚ÑπÔ∏è  Some values are truncated. Use get_scope_variables for full details or save_scope_variables to save to file."))}catch(n){const t=n instanceof Error?n.message:String(n);$(`   ‚ö†Ô∏è Failed to inspect scope variables: ${t}`),$("   Use get_scope_variables for detailed inspection."),e(`[debugger] Error inspecting scope variables: ${n}`)}}}for(const e of v)s.appendResponseLine(e);L&&(s.appendResponseLine(""),s.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${c} lines.`),s.appendResponseLine("   Use get_scope_variables for detailed variable inspection."),s.appendResponseLine(`   Increase maxOutputLines parameter to see more (current: ${c}).`))}});export const evaluateOnCallFrame=b({name:"evaluate_on_call_frame",description:"Evaluate a JavaScript expression in the context of a specific call frame when paused.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{expression:n.string().describe("The JavaScript expression to evaluate."),frameIndex:n.number().int().nonnegative().default(0).describe("The index of the call frame to evaluate in (0 = current frame).")},handler:async(e,n,a)=>{const{expression:s,frameIndex:i}=e.params,o=a.getSelectedPage(),r=R(o);if(!r.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!r.pausedCallFrames||i>=r.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((r.pausedCallFrames?.length??1)-1));const p=r.pausedCallFrames[i],l=await t(o);try{const e=await l.send("Debugger.evaluateOnCallFrame",{callFrameId:p.callFrameId,expression:s,returnByValue:!0});e.exceptionDetails?(n.appendResponseLine("‚ùå Evaluation error:"),n.appendResponseLine(`   ${e.exceptionDetails.exception?.description||e.exceptionDetails.text}`)):(n.appendResponseLine(`‚úÖ Result (frame ${i}: ${p.functionName}):`),n.appendResponseLine("```json"),n.appendResponseLine(JSON.stringify(e.result?.value??e.result,null,2)),n.appendResponseLine("```"))}catch(e){n.appendResponseLine(`‚ùå Failed to evaluate: ${e instanceof Error?e.message:String(e)}`)}}});export const getScopeVariables=b({name:"get_scope_variables",description:"Get detailed variable information from a specific scope when paused at a breakpoint. Supports pagination and search.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),scopeType:n.enum(["local","closure","block","script","global","catch","with","module","wasm-expression-stack"]).optional().describe("Filter to a specific scope type. If omitted, shows all scopes."),variableName:n.string().optional().describe("Specific variable name to inspect in detail. If omitted, shows all variables."),searchTerm:n.string().optional().describe("Search term to filter variable names (case-insensitive substring match)."),pageSize:n.number().int().positive().optional().describe("Maximum number of variables to return per page. When omitted, uses default page size."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based). When omitted, returns the first page."),maxDepth:n.number().int().positive().default(3).optional().describe("Maximum depth for nested object inspection. Default is 3."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated with a hint to use saveToFile."),saveToFile:n.string().optional().describe("Optional file path to save full output. When provided, saves complete output to file without truncation."),maxLineLength:n.number().int().positive().default(1e3).optional().describe("Maximum length of a single variable value or output line. Default is 1000.")},handler:async(e,n,i)=>{const{frameIndex:o,scopeType:r,variableName:p,searchTerm:l,pageSize:c,pageIdx:d,maxDepth:u,maxOutputLines:m,saveToFile:g,maxLineLength:b=1e3}=e.params,f=i.getSelectedPage(),h=R(f),L=a().maxBodySize;if(!h.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!h.pausedCallFrames||o>=h.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((h.pausedCallFrames?.length??1)-1));const y=h.pausedCallFrames[o],$=await t(f),x=[],S=m??100;let w=0;const k=e=>{x.push(e),w+=e.length+1};async function I(e,n,t){const a=[];if(n<=0)return a.push(`${t}[max depth reached]`),a;try{const s=(await $.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;if("object"===s.type&&s.objectId&&"null"!==s.subtype){a.push(`${t}${e.name}: (${s.subtype||s.type}) ${s.description||""}`);const i=await I(s.objectId,n-1,t+"  ");a.push(...i)}else{const{formatted:n,type:i}=v(s,b);a.push(`${t}${e.name}: (${i}) ${n}`)}}else e.get&&a.push(`${t}${e.name}: [getter]`)}catch(e){const n=e instanceof Error?e.message:String(e);a.push(`${t}(unable to retrieve properties: ${n})`)}return a}k(`üì¶ Scope Variables (frame ${o}: ${y.functionName}):`),k("");for(const e of y.scopeChain){if(r&&e.type!==r)continue;if(k(`=== [${e.name?`${e.type}: ${e.name}`:e.type}] ===`),e.object.objectId){try{let n=(await $.send("Runtime.getProperties",{objectId:e.object.objectId,ownProperties:!0,generatePreview:!0})).result||[];if(p){const e=n.find(e=>e.name===p);if(e){if(k(`Variable: ${p}`),e.value){const n=e.value;if("object"===n.type&&n.objectId&&"null"!==n.subtype){k(`Type: ${n.subtype||n.type}`),k(`Description: ${n.description||"N/A"}`),k("Properties:");const e=await I(n.objectId,u??3,"   ");for(const n of e)k(n)}else{const{formatted:e,type:t}=v(n,b);k(`Type: ${t}`),k(`Value: ${e}`)}}}else k(`   Variable "${p}" not found in this scope.`)}else{if(l){const e=l.toLowerCase();if(n=n.filter(n=>n.name.toLowerCase().includes(e)),0===n.length){k(`   No variables matching "${l}" found.`),k("");continue}}const e=s(n,{pageSize:c,pageIdx:d});e.totalPages>1&&(k(`Showing ${e.startIndex+1}-${e.endIndex} of ${n.length} variables (Page ${e.currentPage+1} of ${e.totalPages})`),e.hasNextPage&&k(`Next page: pageIdx=${e.currentPage+1}`),e.hasPreviousPage&&k("Previous page: pageIdx="+(e.currentPage-1)));for(const n of e.items)if(n.value){const e=n.value;if("object"===e.type&&e.objectId&&"null"!==e.subtype){k(`${n.name}: (${e.subtype||e.type}) ${e.description||""}`);const t=await I(e.objectId,(u??3)-1,"   ");for(const e of t)k(e)}else{const{formatted:t,type:a}=v(e,b);k(`${n.name}: (${a}) ${t}`)}}else n.get&&k(`${n.name}: [getter]`)}}catch(e){k(`   (error retrieving properties: ${e instanceof Error?e.message:String(e)})`)}if(k(""),w>=L&&!g)break}else k("   (no properties)"),k("")}if(g){const e=x.join("\n");await i.saveFile((new TextEncoder).encode(e),g),n.appendResponseLine(`‚úÖ Full output saved to ${g} (${x.length} lines)`),n.appendResponseLine("")}let P=0,N=!1;for(let e=0;e<x.length;e++){const t=x[e];if(e>=S||P+t.length>L){N=!0;break}let a=t;t.length>b&&(a=t.substring(0,b)+"... [line truncated]"),n.appendResponseLine(a),P+=a.length+1}N&&(n.appendResponseLine(""),n.appendResponseLine("‚ö†Ô∏è Output truncated: showing first part of the result."),n.appendResponseLine("   Use saveToFile parameter to save full output, or increase maxOutputLines/maxLineLength."),g||n.appendResponseLine('   Example: get_scope_variables({ saveToFile: "/tmp/scope_vars.txt" })'))}});export const saveScopeVariables=b({name:"save_scope_variables",description:"Save all scope variables from the current debug context to a JSON file.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{filePath:n.string().describe("Absolute or relative file path to save the scope variables JSON."),frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),maxDepth:n.number().int().positive().default(5).optional().describe("Maximum depth for nested object serialization. Default is 5."),includeGlobal:n.boolean().default(!1).optional().describe("Include global scope variables. Default is false (globals are very large).")},handler:async(e,n,a)=>{const{filePath:s,frameIndex:i,maxDepth:o,includeGlobal:r}=e.params,p=a.getSelectedPage(),l=R(p);if(!l.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!l.pausedCallFrames||i>=l.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((l.pausedCallFrames?.length??1)-1));const c=l.pausedCallFrames[i],d=await t(p);async function u(e,n,t){if(n<=0||t.has(e))return"[max depth or circular reference]";t.add(e);const a={};try{const s=(await d.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;"object"===s.type&&s.objectId&&"null"!==s.subtype?(s.subtype,a[e.name]=await u(s.objectId,n-1,t)):void 0!==s.value?a[e.name]=s.value:s.unserializableValue?a[e.name]=`[${s.unserializableValue}]`:a[e.name]=`[${s.subtype||s.type}]`}else e.get&&(a[e.name]="[getter]")}catch{return"[error serializing]"}return a}const m={frame:{index:i,functionName:c.functionName,url:c.url,location:{lineNumber:c.location.lineNumber+1,columnNumber:c.location.columnNumber??0}},scopes:{}};for(const e of c.scopeChain){if("global"===e.type&&!r){m.scopes[e.type]="[skipped - use includeGlobal:true to include]";continue}const n=e.name?`${e.type}:${e.name}`:e.type;e.object.objectId?m.scopes[n]=await u(e.object.objectId,o??5,new Set):m.scopes[n]={}}const g=JSON.stringify(m,null,2);await a.saveFile((new TextEncoder).encode(g),s),n.appendResponseLine(`‚úÖ Saved scope variables to ${s}`),n.appendResponseLine(`   Frame: ${c.functionName}`),n.appendResponseLine(`   Scopes saved: ${Object.keys(m.scopes).join(", ")}`)}});export const pauseOnExceptions=b({name:"pause_on_exceptions",description:"Configure whether the debugger should pause on exceptions (none, uncaught, or all).",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{state:n.enum(["none","uncaught","all"]).describe("When to pause on exceptions.")},handler:async(e,n,t)=>{const{state:a}=e.params,s=t.getSelectedPage(),i=await $(s);try{switch(await i.send("Debugger.setPauseOnExceptions",{state:a}),n.appendResponseLine(`‚úÖ Exception pausing set to: ${a}`),a){case"none":n.appendResponseLine("   Debugger will not pause on any exceptions.");break;case"uncaught":n.appendResponseLine("   Debugger will pause only on uncaught exceptions.");break;case"all":n.appendResponseLine("   Debugger will pause on all exceptions (caught and uncaught).")}}catch(e){n.appendResponseLine(`‚ùå Failed to set exception pausing: ${e instanceof Error?e.message:String(e)}`)}}});export const disableDebugger=b({name:"disable_debugger",description:"Disable the JavaScript debugger on the current page and remove all breakpoints.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=R(s);if(!i.enabled)return void n.appendResponseLine("‚ÑπÔ∏è Debugger is already disabled.");const o=await t(s);try{await o.send("Debugger.disable"),i.enabled=!1,i.breakpoints.clear(),i.isPaused=!1,i.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Debugger disabled."),n.appendResponseLine("   All breakpoints have been removed.")}catch(e){n.appendResponseLine(`‚ùå Failed to disable debugger: ${e instanceof Error?e.message:String(e)}`)}}});export const getPossibleBreakpoints=b({name:"get_possible_breakpoints",description:"Discover all valid breakpoint locations in a script at a specific line. Useful for minified code.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to search for breakpoints (1-based, as shown in editors)."),startColumn:n.number().int().nonnegative().optional().describe("Optional start column to filter results (0-based). Defaults to 0."),endColumn:n.number().int().nonnegative().optional().describe("Optional end column to filter results (0-based). Defaults to end of line."),maxCount:n.number().int().positive().optional().describe("Maximum number of locations to return. Defaults to 20.")},handler:async(e,n,t)=>{const{urlRegex:a,lineNumber:s,startColumn:i,endColumn:o,maxCount:p=20}=e.params,c=t.getSelectedPage(),d=await $(c);if(void 0!==i&&i<0)return n.appendResponseLine(`‚ùå Invalid startColumn: ${i}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Use startColumn=0 to search from the beginning of the line.");if(void 0!==o&&o<0)return n.appendResponseLine(`‚ùå Invalid endColumn: ${o}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Omit endColumn to search to the end of the line.");if(void 0!==i&&void 0!==o&&i>o)return n.appendResponseLine(`‚ùå Invalid column range: startColumn (${i}) > endColumn (${o})`),n.appendResponseLine("   startColumn must be less than or equal to endColumn."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Swap the values or adjust the range.");const u=s-1,m=await r(d,a);if(0===m.length)return n.appendResponseLine(`‚ùå No scripts found matching pattern: ${a}`),void n.appendResponseLine("   üí° Suggestion: Verify the script is loaded and the URL pattern is correct.");let g=[];for(const e of m){const n=i??0,t=o??n+100,a=(await l(d,e.scriptId,u,n,u,t,e.url)).filter(e=>!(void 0!==i&&e.columnNumber<i)&&!(void 0!==o&&e.columnNumber>o));g=g.concat(a)}if(0===g.length)return n.appendResponseLine(`‚ùå No valid breakpoint locations found at line ${s}`),void 0===i&&void 0===o||n.appendResponseLine(`   Column range: ${i??0} - ${o??"end"}`),void n.appendResponseLine("   üí° Suggestion: Try a different line or expand the column range.");g.sort((e,n)=>{const t=e.scriptUrl.localeCompare(n.scriptUrl);return 0!==t?t:e.columnNumber-n.columnNumber});const b=g.length,f=b>p,h=f?g.slice(0,p):g;n.appendResponseLine(`üìç Possible breakpoint locations at line ${s}:`),n.appendResponseLine(`   URL pattern: ${a}`),void 0===i&&void 0===o||n.appendResponseLine(`   Column range: ${i??0} - ${o??"end"}`),n.appendResponseLine("");for(const e of h)n.appendResponseLine(`   ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`);f?(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Results truncated: showing ${p} of ${b} locations`),n.appendResponseLine("   üí° Suggestion: Use startColumn/endColumn to narrow the search range.")):(n.appendResponseLine(""),n.appendResponseLine(`Found ${b} valid breakpoint location(s).`))}});export async function ensureDebuggerEnabledForPage(e){await $(e)}
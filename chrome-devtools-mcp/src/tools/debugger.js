/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as n}from"../third_party/index.js";import{getCdpSession as t}from"../utils/cdp.js";import{getConfig as a}from"../utils/config.js";import{paginate as s}from"../utils/pagination.js";import{clearParseResultCache as i}from"./analysis.js";import{ToolCategory as o}from"./categories.js";import{findMatchingScripts as r,findNearestBreakpointLocation as p,queryPossibleBreakpoints as l,cacheScript as c,clearScriptCache as u,getScriptCache as d,getScriptSource as m}from"../utils/smartBreakpointUtils.js";import{ScriptCacheRegistry as b}from"../utils/scriptCacheRegistry.js";import{defineTool as g}from"./ToolDefinition.js";import{extractContextCode as f,formatContextCodeOutput as h}from"../utils/contextCodeUtils.js";function v(e,n=a().maxInlineStringLength){const t=e.type||"unknown",s=e.subtype;if(void 0!==e.value){const s=function(e,n=a().maxInlineStringLength){if(void 0===e)return{formatted:"undefined",truncated:!1};if(null===e)return{formatted:"null",truncated:!1};let t;if("string"==typeof e)t=JSON.stringify(e);else if("object"==typeof e)try{t=JSON.stringify(e)}catch{t=String(e)}else t=String(e);return t.length>n?{formatted:t.substring(0,n)+"...",truncated:!0}:{formatted:t,truncated:!1}}(e.value,n);return{...s,type:t}}if(e.unserializableValue)return{formatted:e.unserializableValue,truncated:!1,type:t};if(e.preview){const a=e.preview;if(a.overflow){return{formatted:`{${(a.properties||[]).slice(0,5).map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}, ...}`,truncated:!0,type:s||t}}if(a.properties){const e=`{${a.properties.map(e=>`${e.name}: ${e.value??e.type}`).join(", ")}}`;return e.length>n?{formatted:e.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:e,truncated:!1,type:s||t}}}if(e.description){const a=e.description;return a.length>n?{formatted:a.substring(0,n)+"...",truncated:!0,type:s||t}:{formatted:a,truncated:!1,type:s||t}}return{formatted:`[${s||t}]`,truncated:!1,type:s||t}}export function formatPreview(e){if(!e)return"[no preview]";if("object"===e.type){const n=e.properties||[];if(0===n.length)return"array"===e.subtype?"[]":"{}";const t=n.slice(0,3).map(e=>`${e.name}: ${e.value??e.type}`).join(", ");return"array"===e.subtype?e.overflow?`[${t}, ...]`:`[${t}]`:e.overflow?`{${t}, ...}`:`{${t}}`}return e.description||String(e.value??"[unknown]")}export async function inspectScopeVariablesOptimized(n,t,a){const s=[];let i=!1;if(a.skipScopeVariables)return s.push("   [Scope inspection skipped - use get_scope_variables for details]"),{lines:s,hasTruncatedValues:!1};const o=t.map(async t=>{if("global"===t.type)return{scopeName:"global",lines:["   [global] (use get_scope_variables to inspect)"],hasTruncatedValues:!1};const s=t.name?`${t.type}: ${t.name}`:t.type,i=[`   [${s}]`];let o=!1;if(!t.object.objectId)return i.push("      (no properties)"),{scopeName:s,lines:i,hasTruncatedValues:!1};try{const e=(await n.send("Runtime.getProperties",{objectId:t.object.objectId,ownProperties:!0,generatePreview:!0})).result||[],s=e.slice(0,a.maxPropertiesPerScope),r=e.length>a.maxPropertiesPerScope;for(const e of s)if(e.value)if(a.useObjectPreviews&&e.value.preview){const n=formatPreview(e.value.preview),t=e.value.subtype||e.value.type;i.push(`      ${e.name}: (${t}) ${n}`),e.value.preview.overflow&&(o=!0)}else{const{formatted:n,truncated:t,type:a}=v(e.value);o=o||t;const s=t?" [truncated]":"";i.push(`      ${e.name}: (${a}) ${n}${s}`)}else e.get&&i.push(`      ${e.name}: [getter]`);r&&(i.push(`      ... and ${e.length-a.maxPropertiesPerScope} more properties`),o=!0)}catch(n){const t=n instanceof Error?n.message:String(n);i.push(`      (unable to retrieve properties: ${t})`),e(`[debugger] Failed to retrieve properties for scope ${s}: ${n}`)}return{scopeName:s,lines:i,hasTruncatedValues:o}}),r=await Promise.all(o);for(const e of r)s.push(...e.lines),i=i||e.hasTruncatedValues;return{lines:s,hasTruncatedValues:i}}const y=new WeakMap;function R(e){let n=y.get(e);return n||(n={enabled:!1,breakpoints:new Map,isPaused:!1},y.set(e,n)),n}const L=new WeakSet;async function $(n){const a=await t(n),s=R(n);if(s.enabled||(await a.send("Debugger.enable"),s.enabled=!0,a.on("Debugger.scriptParsed",async n=>{const t=n.scriptId,s=n.url||"";if(c(a,{scriptId:t,url:s,startLine:n.startLine,startColumn:n.startColumn,endLine:n.endLine,endColumn:n.endColumn}),s)try{const e=(await a.send("Debugger.getScriptSource",{scriptId:t})).scriptSource;if(e){const n=b.getOrCreate(a);await n.cacheScript(t,s,e)}}catch(n){e(`[debugger] Failed to cache script source for ${t}: ${n}`)}e(`[debugger] Script parsed: ${s||t}`)}),a.on("Debugger.paused",n=>{s.isPaused=!0,s.pausedCallFrames=n.callFrames?.map(e=>({callFrameId:e.callFrameId,functionName:e.functionName||"(anonymous)",location:{scriptId:e.location.scriptId,lineNumber:e.location.lineNumber,columnNumber:e.location.columnNumber},url:e.url||"",scopeChain:e.scopeChain?.map(e=>({type:e.type,object:{type:e.object?.type,objectId:e.object?.objectId},name:e.name}))||[]})),e("[debugger] Execution paused at breakpoint")}),a.on("Debugger.resumed",()=>{s.isPaused=!1,s.pausedCallFrames=void 0,e("[debugger] Execution resumed")})),!L.has(n)){let t;L.add(n);try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}a.on("Page.frameStartedLoading",async o=>{let r=!t||o.frameId===t;if(!r)try{const e=await a.send("Page.getFrameTree"),n=e.frameTree?.frame?.id;o.frameId===n&&(r=!0,t=n)}catch{r=!0}if(r){if(u(a),i(a),e("[debugger] Script cache and parse result cache cleared on navigation"),s.breakpoints.size>0){e("[debugger] Main frame started loading, restoring breakpoints immediately...");try{await async function(n,t){const a=R(n);try{await t.send("Emulation.setScriptExecutionDisabled",{value:!0}),e("[debugger] Script execution disabled temporarily")}catch{}try{await t.send("Debugger.enable")}catch{}for(const[n,s]of a.breakpoints)try{const a={lineNumber:s.resolvedLineNumber-1,urlRegex:s.urlPattern,columnNumber:s.resolvedColumnNumber};s.condition&&(a.condition=s.condition);const i=await t.send("Debugger.setBreakpointByUrl",a);s.breakpointId=i.breakpointId,e(`[debugger] Restored breakpoint "${n}" after navigation`)}catch(t){e(`[debugger] Failed to restore breakpoint "${n}": ${t}`)}try{await t.send("Emulation.setScriptExecutionDisabled",{value:!1}),e("[debugger] Script execution re-enabled")}catch{}}(n,a)}catch(n){e(`[debugger] Error restoring breakpoints: ${n}`)}}try{const e=await a.send("Page.getFrameTree");t=e.frameTree?.frame?.id}catch{}}});try{await a.send("Page.enable")}catch{}}return a}export const setBreakpoint=g({name:"set_breakpoint",description:'Set a JavaScript breakpoint at a specific line in a file matching a URL pattern.\n\nThe breakpoint will cause code execution to pause when that line is reached.\nUse url_regex to match files (e.g., ".*app\\.js.*" matches URLs containing "app.js").\n\nSmart Snapping: When you specify a columnNumber, the tool will automatically "snap" to the\nnearest valid breakpoint position if the exact position isn\'t valid. This is especially useful\nfor minified/single-line JavaScript where valid breakpoint positions may not be obvious.\n\nNote: Line numbers in CDP are 0-based, so line 10 in your editor = lineNumber 9.\nThis tool automatically converts 1-based line numbers to 0-based for convenience.\n\nExample:\n- Set breakpoint at line 25 of main.js: urlRegex=".*main\\.js.*", lineNumber=25\n- Set conditional breakpoint: urlRegex=".*api\\.js.*", lineNumber=42, condition="response.status !== 200"\n- Set breakpoint with column snapping: urlRegex=".*minified\\.js.*", lineNumber=1, columnNumber=500',annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("A unique identifier for this breakpoint (used to remove it later)."),urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to set the breakpoint at (1-based, as shown in editors)."),columnNumber:n.number().int().nonnegative().optional().describe("Optional target column number (0-based) for smart snapping. When specified, the tool will find the nearest valid breakpoint position within snapRange of this column."),snapRange:n.number().int().positive().optional().describe("Search range around the target column for finding valid breakpoint positions. Defaults to 100."),condition:n.string().optional().describe("Optional JavaScript expression. The breakpoint only triggers when this evaluates to true.")},handler:async(e,n,t)=>{const{breakpointId:a,urlRegex:s,lineNumber:i,columnNumber:o,snapRange:c=100,condition:u}=e.params,m=t.getSelectedPage(),b=await $(m),g=R(m);if(void 0!==o&&o<0)return n.appendResponseLine(`‚ùå Invalid column number: ${o}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid column positions"),void n.appendResponseLine("   ‚Ä¢ Column 0 represents the start of the line");const f=i-1,h=o??0;let v=h,y=!1;if(void 0!==o){const e=await r(b,s);if(0===e.length)return n.appendResponseLine(`‚ùå Failed to set breakpoint: No scripts found matching pattern "${s}"`),n.appendResponseLine(`   Requested position: line ${i}, column ${o}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded in the page"),n.appendResponseLine("   ‚Ä¢ Check that the URL pattern is correct (use regex syntax)"),void n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations");const t=Math.max(0,h-c),a=h+c;let u=[];for(const n of e){const e=await l(b,n.scriptId,f,t,f,a,n.url);u=u.concat(e)}if(0===u.length)return n.appendResponseLine("‚ùå Failed to set breakpoint: No valid breakpoint positions found"),n.appendResponseLine(`   Requested position: line ${i}, column ${o}`),n.appendResponseLine(`   Search range: columns ${t} - ${a}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations on this line"),n.appendResponseLine(`   ‚Ä¢ Try increasing snapRange (currently ${c}) to search a wider area`),void n.appendResponseLine("   ‚Ä¢ Verify the line number contains executable code");const d=p(u,h);d&&(v=d.columnNumber,y=v!==h)}const L={lineNumber:f,urlRegex:s,columnNumber:v};u&&(L.condition=u);try{const e=await b.send("Debugger.setBreakpointByUrl",L),t=e.locations;if(t&&t.length>0){const r=t[0],p=r.lineNumber+1,l=r.columnNumber,c=y||p!==i||l!==v,m={breakpointId:e.breakpointId,urlPattern:s,lineNumber:i,columnNumber:o,resolvedLineNumber:p,resolvedColumnNumber:l,condition:u,wasSnapped:c};g.breakpoints.set(a,m),n.appendResponseLine(`‚úÖ Breakpoint "${a}" set successfully`),c&&n.appendResponseLine("‚ö° Snapped to nearest valid position"),n.appendResponseLine(`   URL pattern: ${s}`),void 0!==o?(n.appendResponseLine(`   Requested: line ${i}, column ${o}`),n.appendResponseLine(`   Resolved:  line ${p}, column ${l}`)):(n.appendResponseLine(`   Line: ${i}`),p!==i&&n.appendResponseLine(`   Resolved line: ${p}`)),u&&n.appendResponseLine(`   Condition: ${u}`),n.appendResponseLine(`   CDP breakpoint ID: ${e.breakpointId}`),n.appendResponseLine(""),n.appendResponseLine("üìç Resolved locations:");for(const e of t){const t=d(b).get(e.scriptId),a=t?.url||`Script ${e.scriptId}`;n.appendResponseLine(`   ${a}:${e.lineNumber+1}:${e.columnNumber}`)}}else await b.send("Debugger.removeBreakpoint",{breakpointId:e.breakpointId}),n.appendResponseLine("‚ùå Failed to set breakpoint: No matching scripts found"),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${i}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Verify the URL pattern matches a loaded script"),n.appendResponseLine("   ‚Ä¢ Check that the line number contains executable code"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations")}catch(e){n.appendResponseLine(`‚ùå Failed to set breakpoint: ${e instanceof Error?e.message:String(e)}`),n.appendResponseLine(`   URL pattern: ${s}`),n.appendResponseLine(`   Line: ${i}`),void 0!==o&&n.appendResponseLine(`   Column: ${o}`),n.appendResponseLine(""),n.appendResponseLine("üí° Suggestions:"),n.appendResponseLine("   ‚Ä¢ Use get_possible_breakpoints to discover valid locations"),n.appendResponseLine("   ‚Ä¢ Verify the script is loaded and the URL pattern is correct")}}});export const removeBreakpoint=g({name:"remove_breakpoint",description:"Remove a previously set JavaScript breakpoint by its ID.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{breakpointId:n.string().describe("The ID of the breakpoint to remove (as specified when setting it).")},handler:async(e,n,a)=>{const{breakpointId:s}=e.params,i=a.getSelectedPage(),o=R(i),r=o.breakpoints.get(s);if(!r)return void n.appendResponseLine(`‚ö†Ô∏è Breakpoint "${s}" not found.`);const p=await t(i);try{await p.send("Debugger.removeBreakpoint",{breakpointId:r.breakpointId}),o.breakpoints.delete(s),n.appendResponseLine(`‚úÖ Removed breakpoint "${s}"`)}catch(e){n.appendResponseLine(`‚ùå Failed to remove breakpoint: ${e instanceof Error?e.message:String(e)}`)}}});export const listBreakpoints=g({name:"list_breakpoints",description:"List all active JavaScript breakpoints on the current page. Supports pagination and search.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{searchTerm:n.string().optional().describe("Search term to filter breakpoints by ID or URL pattern (case-insensitive)."),pageSize:n.number().int().positive().optional().describe("Maximum number of breakpoints to return per page."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based).")},handler:async(e,n,t)=>{const{searchTerm:a,pageSize:i,pageIdx:o}=e.params,r=R(t.getSelectedPage());if(0===r.breakpoints.size)return void n.appendResponseLine("No active breakpoints.");let p=Array.from(r.breakpoints.entries());if(a){const e=a.toLowerCase();if(p=p.filter(([n,t])=>n.toLowerCase().includes(e)||t.urlPattern.toLowerCase().includes(e)),0===p.length)return void n.appendResponseLine(`No breakpoints matching "${a}" found.`)}const l=s(p,{pageSize:i,pageIdx:o});n.appendResponseLine(`Active breakpoints (${p.length} total):`),l.totalPages>1&&(n.appendResponseLine(`Showing ${l.startIndex+1}-${l.endIndex} (Page ${l.currentPage+1} of ${l.totalPages})`),l.hasNextPage&&n.appendResponseLine(`Next page: pageIdx=${l.currentPage+1}`)),n.appendResponseLine("");for(const[e,t]of l.items)n.appendResponseLine(`üìç ${e}`),n.appendResponseLine(`   URL pattern: ${t.urlPattern}`),n.appendResponseLine(`   Line: ${t.lineNumber}`),void 0!==t.columnNumber&&n.appendResponseLine(`   Column: ${t.columnNumber}`),t.condition&&n.appendResponseLine(`   Condition: ${t.condition}`),n.appendResponseLine("")}});export const clearAllBreakpoints=g({name:"clear_all_breakpoints",description:"Remove all active JavaScript breakpoints on the current page.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=R(s),o=await t(s),r=i.breakpoints.size,p=[];for(const[e,n]of i.breakpoints)try{await o.send("Debugger.removeBreakpoint",{breakpointId:n.breakpointId})}catch(n){p.push(`${e}: ${n instanceof Error?n.message:String(n)}`)}if(i.breakpoints.clear(),p.length>0){n.appendResponseLine(`‚ö†Ô∏è Cleared ${r-p.length}/${r} breakpoints.`),n.appendResponseLine("Errors:");for(const e of p)n.appendResponseLine(`   ${e}`)}else n.appendResponseLine(`‚úÖ Cleared ${r} breakpoint(s).`)}});export const resumeExecution=g({name:"resume_execution",description:"Resume JavaScript execution after hitting a breakpoint.\n\nUse this when the debugger is paused at a breakpoint to continue running the code.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=R(s);if(!i.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const o=await t(s);try{await o.send("Debugger.resume"),i.isPaused=!1,i.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Execution resumed.")}catch(e){n.appendResponseLine(`‚ùå Failed to resume: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOver=g({name:"step_over",description:"Step over to the next line of code (doesn't step into function calls).\n\nUse this when paused at a breakpoint to execute the current line and move to the next.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!R(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepOver"),n.appendResponseLine("‚úÖ Stepped over to next line.")}catch(e){n.appendResponseLine(`‚ùå Failed to step over: ${e instanceof Error?e.message:String(e)}`)}}});export const stepInto=g({name:"step_into",description:"Step into a function call at the current line.\n\nUse this when paused at a breakpoint and the current line has a function call you want to debug.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!R(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepInto"),n.appendResponseLine("‚úÖ Stepped into function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step into: ${e instanceof Error?e.message:String(e)}`)}}});export const stepOut=g({name:"step_out",description:"Step out of the current function.\n\nUse this when paused inside a function and you want to return to the caller.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage();if(!R(s).isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");const i=await t(s);try{await i.send("Debugger.stepOut"),n.appendResponseLine("‚úÖ Stepped out of function.")}catch(e){n.appendResponseLine(`‚ùå Failed to step out: ${e instanceof Error?e.message:String(e)}`)}}});export const getDebuggerStatus=g({name:"get_debugger_status",description:"Get the current status of the JavaScript debugger.\n\nReturns whether the debugger is enabled, paused, and shows:\n- Current call stack if paused\n- Code context around the current execution location (with line numbers and position annotations)\n- Local variables and scope information for the current frame\n- Values are truncated if too long; use get_scope_variables for full details\n\nThe code context is especially useful for understanding minified code, as it will be\nautomatically formatted with proper indentation and position mappings for breakpoint targeting.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).optional().describe("The call frame index to show variables for (0 = current frame). Default is 0."),contextLines:n.number().int().nonnegative().default(5).optional().describe("Number of lines to show before and after the current line. Set to 0 to disable code context. Default is 5."),formatMinified:n.boolean().default(!0).optional().describe("Whether to format minified code for better readability. Default is true."),maxPropertiesPerScope:n.number().int().positive().optional().describe("Maximum number of properties to show per scope. Default is 10."),skipScopeVariables:n.boolean().optional().describe("Skip scope variable inspection entirely for faster execution. Default is false."),useObjectPreviews:n.boolean().optional().describe("Use object preview data instead of fetching full properties. Default is true."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated."),maxCallStackFrames:n.number().int().positive().default(20).optional().describe("Maximum number of call stack frames to display. Default is 20.")},handler:async(n,s,i)=>{const o=i.getSelectedPage(),r=R(o),p=n.params.frameIndex??0,l=n.params.contextLines??5,c=n.params.formatMinified??!0,u=n.params.maxOutputLines??100,d=n.params.maxCallStackFrames??20,b={maxPropertiesPerScope:n.params.maxPropertiesPerScope??a().debugger.maxPropertiesPerScope,skipScopeVariables:n.params.skipScopeVariables??a().debugger.skipScopeVariables,useObjectPreviews:n.params.useObjectPreviews??a().debugger.useObjectPreviews,maxObjectDepth:a().debugger.maxObjectDepth},g=[];let v=!1;const y=e=>g.length>=u?(v=!0,!1):(g.push(e),!0),L=e=>{for(const n of e)if(!y(n))return!1;return!0};if(y("üîç Debugger Status:"),y("   Enabled: "+(r.enabled?"Yes":"No")),y("   Paused: "+(r.isPaused?"Yes":"No")),y(`   Active breakpoints: ${r.breakpoints.size}`),r.isPaused&&r.pausedCallFrames){if(p>=r.pausedCallFrames.length){y(""),y(`‚ùå Invalid frame index: ${p}`),y("   Valid range: 0-"+(r.pausedCallFrames.length-1));for(const e of g)s.appendResponseLine(e);return}y(""),y("üìö Call Stack:");const n=r.pausedCallFrames.length,a=Math.min(n,d),i=n>d;for(let e=0;e<a&&!v;e++){const n=r.pausedCallFrames[e],t=e===p?" ‚ñ∂":"";y(`   ${e}: ${n.functionName} at ${n.url||"(unknown)"}:${n.location.lineNumber+1}:${n.location.columnNumber??0}${t}`)}i&&!v&&y(`   ... and ${n-d} more frames`);const u=r.pausedCallFrames[p],R=await t(o);if(l>0&&!v){y("");try{const e=await m(R,u.location.scriptId);if(null===e)y(`‚ö†Ô∏è Source unavailable for script ${u.location.scriptId}`),y("   The script source could not be retrieved from the browser.");else{const n=f(e,{lineNumber:u.location.lineNumber+1,columnNumber:u.location.columnNumber??0,contextLines:l,formatMinified:c}),t=h(n,u.location.lineNumber+1,u.location.columnNumber??0,u.url,u.functionName);L(t.split("\n"))}}catch(n){const t=n instanceof Error?n.message:String(n);y(`‚ö†Ô∏è Failed to retrieve code context: ${t}`),e(`[debugger] Error retrieving code context for script ${u.location.scriptId}: ${n}`)}}if(!v){y(""),y(`üì¶ Scope Variables (frame ${p}: ${u.functionName}):`);try{const{lines:e,hasTruncatedValues:n}=await inspectScopeVariablesOptimized(R,u.scopeChain,b);L(e),n&&!v&&(y(""),y("‚ÑπÔ∏è  Some values are truncated. Use get_scope_variables for full details or save_scope_variables to save to file."))}catch(n){const t=n instanceof Error?n.message:String(n);y(`   ‚ö†Ô∏è Failed to inspect scope variables: ${t}`),y("   Use get_scope_variables for detailed inspection."),e(`[debugger] Error inspecting scope variables: ${n}`)}}}for(const e of g)s.appendResponseLine(e);v&&(s.appendResponseLine(""),s.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${u} lines.`),s.appendResponseLine("   Use get_scope_variables for detailed variable inspection."),s.appendResponseLine(`   Increase maxOutputLines parameter to see more (current: ${u}).`))}});export const evaluateOnCallFrame=g({name:"evaluate_on_call_frame",description:"Evaluate a JavaScript expression in the context of a specific call frame when paused.\n\nThis allows you to inspect variables and state at any point in the call stack.\nUse frameIndex 0 for the current (topmost) frame, 1 for the caller, etc.",annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{expression:n.string().describe("The JavaScript expression to evaluate."),frameIndex:n.number().int().nonnegative().default(0).describe("The index of the call frame to evaluate in (0 = current frame).")},handler:async(e,n,a)=>{const{expression:s,frameIndex:i}=e.params,o=a.getSelectedPage(),r=R(o);if(!r.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!r.pausedCallFrames||i>=r.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((r.pausedCallFrames?.length??1)-1));const p=r.pausedCallFrames[i],l=await t(o);try{const e=await l.send("Debugger.evaluateOnCallFrame",{callFrameId:p.callFrameId,expression:s,returnByValue:!0});e.exceptionDetails?(n.appendResponseLine("‚ùå Evaluation error:"),n.appendResponseLine(`   ${e.exceptionDetails.exception?.description||e.exceptionDetails.text}`)):(n.appendResponseLine(`‚úÖ Result (frame ${i}: ${p.functionName}):`),n.appendResponseLine("```json"),n.appendResponseLine(JSON.stringify(e.result?.value??e.result,null,2)),n.appendResponseLine("```"))}catch(e){n.appendResponseLine(`‚ùå Failed to evaluate: ${e instanceof Error?e.message:String(e)}`)}}});export const getScopeVariables=g({name:"get_scope_variables",description:'Get detailed variable information from a specific scope when paused at a breakpoint.\n\nUse this to inspect variables in full detail, including nested objects and long strings.\nYou can also inspect a specific variable by name to see its complete value.\nSupports pagination and search to handle large numbers of variables.\n\nScope types:\n- "local": Variables declared in the current function\n- "closure": Variables from enclosing scopes (closures)\n- "block": Block-scoped variables (let/const in blocks)\n- "script": Script-level variables\n- "global": Global variables (window object properties)',annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),scopeType:n.enum(["local","closure","block","script","global","catch","with","module","wasm-expression-stack"]).optional().describe("Filter to a specific scope type. If omitted, shows all scopes."),variableName:n.string().optional().describe("Specific variable name to inspect in detail. If omitted, shows all variables."),searchTerm:n.string().optional().describe("Search term to filter variable names (case-insensitive substring match)."),pageSize:n.number().int().positive().optional().describe("Maximum number of variables to return per page. When omitted, uses default page size."),pageIdx:n.number().int().min(0).optional().describe("Page number to return (0-based). When omitted, returns the first page."),maxDepth:n.number().int().positive().default(3).optional().describe("Maximum depth for nested object inspection. Default is 3."),maxOutputLines:n.number().int().positive().default(100).optional().describe("Maximum number of output lines. Default is 100. When exceeded, output is truncated with a hint to use saveToFile."),saveToFile:n.string().optional().describe("Optional file path to save full output. When provided, saves complete output to file without truncation.")},handler:async(e,n,a)=>{const{frameIndex:i,scopeType:o,variableName:r,searchTerm:p,pageSize:l,pageIdx:c,maxDepth:u,maxOutputLines:d,saveToFile:m}=e.params,b=a.getSelectedPage(),g=R(b);if(!g.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!g.pausedCallFrames||i>=g.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((g.pausedCallFrames?.length??1)-1));const f=g.pausedCallFrames[i],h=await t(b),y=[],L=d??100;async function $(e,n,t){const a=[];if(n<=0)return a.push(`${t}[max depth reached]`),a;try{const s=(await h.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;if("object"===s.type&&s.objectId&&"null"!==s.subtype){a.push(`${t}${e.name}: (${s.subtype||s.type}) ${s.description||""}`);const i=await $(s.objectId,n-1,t+"  ");a.push(...i)}else{const{formatted:n,type:i}=v(s,1e4);a.push(`${t}${e.name}: (${i}) ${n}`)}}else e.get&&a.push(`${t}${e.name}: [getter]`)}catch(e){const n=e instanceof Error?e.message:String(e);a.push(`${t}(unable to retrieve properties: ${n})`)}return a}y.push(`üì¶ Scope Variables (frame ${i}: ${f.functionName}):`),y.push("");for(const e of f.scopeChain){if(o&&e.type!==o)continue;const n=e.name?`${e.type}: ${e.name}`:e.type;if(y.push(`=== [${n}] ===`),e.object.objectId){try{let n=(await h.send("Runtime.getProperties",{objectId:e.object.objectId,ownProperties:!0,generatePreview:!0})).result||[];if(r){const e=n.find(e=>e.name===r);if(e){if(y.push(`Variable: ${r}`),e.value){const n=e.value;if("object"===n.type&&n.objectId&&"null"!==n.subtype){y.push(`Type: ${n.subtype||n.type}`),y.push(`Description: ${n.description||"N/A"}`),y.push("Properties:");const e=await $(n.objectId,u??3,"   ");y.push(...e)}else{const{formatted:e,type:t}=v(n,1e5);y.push(`Type: ${t}`),y.push(`Value: ${e}`)}}}else y.push(`   Variable "${r}" not found in this scope.`)}else{if(p){const e=p.toLowerCase();if(n=n.filter(n=>n.name.toLowerCase().includes(e)),0===n.length){y.push(`   No variables matching "${p}" found.`),y.push("");continue}}const e=s(n,{pageSize:l,pageIdx:c});e.totalPages>1&&(y.push(`Showing ${e.startIndex+1}-${e.endIndex} of ${n.length} variables (Page ${e.currentPage+1} of ${e.totalPages})`),e.hasNextPage&&y.push(`Next page: pageIdx=${e.currentPage+1}`),e.hasPreviousPage&&y.push("Previous page: pageIdx="+(e.currentPage-1)));for(const n of e.items)if(n.value){const e=n.value;if("object"===e.type&&e.objectId&&"null"!==e.subtype){y.push(`${n.name}: (${e.subtype||e.type}) ${e.description||""}`);const t=await $(e.objectId,(u??3)-1,"   ");y.push(...t)}else{const{formatted:t,type:a}=v(e,1e4);y.push(`${n.name}: (${a}) ${t}`)}}else n.get&&y.push(`${n.name}: [getter]`)}}catch(e){y.push(`   (error retrieving properties: ${e instanceof Error?e.message:String(e)})`)}y.push("")}else y.push("   (no properties)"),y.push("")}if(m){const e=y.join("\n");await a.saveFile((new TextEncoder).encode(e),m),n.appendResponseLine(`‚úÖ Full output saved to ${m} (${y.length} lines)`),n.appendResponseLine("")}const x=y.length>L,w=x?y.slice(0,L):y;for(const e of w)n.appendResponseLine(e);x&&(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Output truncated: showing ${L} of ${y.length} lines.`),n.appendResponseLine("   Use saveToFile parameter to save full output, or increase maxOutputLines."),m||n.appendResponseLine('   Example: get_scope_variables({ saveToFile: "/tmp/scope_vars.txt" })'))}});export const saveScopeVariables=g({name:"save_scope_variables",description:"Save all scope variables from the current debug context to a JSON file.\n\nThis is useful for capturing the complete state of variables for analysis, especially when dealing with large objects or binary data.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{filePath:n.string().describe("Absolute or relative file path to save the scope variables JSON."),frameIndex:n.number().int().nonnegative().default(0).describe("The call frame index (0 = current frame)."),maxDepth:n.number().int().positive().default(5).optional().describe("Maximum depth for nested object serialization. Default is 5."),includeGlobal:n.boolean().default(!1).optional().describe("Include global scope variables. Default is false (globals are very large).")},handler:async(e,n,a)=>{const{filePath:s,frameIndex:i,maxDepth:o,includeGlobal:r}=e.params,p=a.getSelectedPage(),l=R(p);if(!l.isPaused)return void n.appendResponseLine("‚ö†Ô∏è Debugger is not currently paused.");if(!l.pausedCallFrames||i>=l.pausedCallFrames.length)return void n.appendResponseLine("‚ö†Ô∏è Invalid frame index. Available frames: 0-"+((l.pausedCallFrames?.length??1)-1));const c=l.pausedCallFrames[i],u=await t(p);async function d(e,n,t){if(n<=0||t.has(e))return"[max depth or circular reference]";t.add(e);const a={};try{const s=(await u.send("Runtime.getProperties",{objectId:e,ownProperties:!0,generatePreview:!0})).result||[];for(const e of s)if(e.value){const s=e.value;"object"===s.type&&s.objectId&&"null"!==s.subtype?(s.subtype,a[e.name]=await d(s.objectId,n-1,t)):void 0!==s.value?a[e.name]=s.value:s.unserializableValue?a[e.name]=`[${s.unserializableValue}]`:a[e.name]=`[${s.subtype||s.type}]`}else e.get&&(a[e.name]="[getter]")}catch{return"[error serializing]"}return a}const m={frame:{index:i,functionName:c.functionName,url:c.url,location:{lineNumber:c.location.lineNumber+1,columnNumber:c.location.columnNumber??0}},scopes:{}};for(const e of c.scopeChain){if("global"===e.type&&!r){m.scopes[e.type]="[skipped - use includeGlobal:true to include]";continue}const n=e.name?`${e.type}:${e.name}`:e.type;e.object.objectId?m.scopes[n]=await d(e.object.objectId,o??5,new Set):m.scopes[n]={}}const b=JSON.stringify(m,null,2);await a.saveFile((new TextEncoder).encode(b),s),n.appendResponseLine(`‚úÖ Saved scope variables to ${s}`),n.appendResponseLine(`   Frame: ${c.functionName}`),n.appendResponseLine(`   Scopes saved: ${Object.keys(m.scopes).join(", ")}`)}});export const pauseOnExceptions=g({name:"pause_on_exceptions",description:'Configure whether the debugger should pause on exceptions.\n\nOptions:\n- "none": Never pause on exceptions\n- "uncaught": Only pause on uncaught exceptions\n- "all": Pause on all exceptions (caught and uncaught)',annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{state:n.enum(["none","uncaught","all"]).describe("When to pause on exceptions.")},handler:async(e,n,t)=>{const{state:a}=e.params,s=t.getSelectedPage(),i=await $(s);try{switch(await i.send("Debugger.setPauseOnExceptions",{state:a}),n.appendResponseLine(`‚úÖ Exception pausing set to: ${a}`),a){case"none":n.appendResponseLine("   Debugger will not pause on any exceptions.");break;case"uncaught":n.appendResponseLine("   Debugger will pause only on uncaught exceptions.");break;case"all":n.appendResponseLine("   Debugger will pause on all exceptions (caught and uncaught).")}}catch(e){n.appendResponseLine(`‚ùå Failed to set exception pausing: ${e instanceof Error?e.message:String(e)}`)}}});export const disableDebugger=g({name:"disable_debugger",description:"Disable the JavaScript debugger on the current page.\n\nThis removes all breakpoints and stops debugging. Use this when you're done debugging.",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{},handler:async(e,n,a)=>{const s=a.getSelectedPage(),i=R(s);if(!i.enabled)return void n.appendResponseLine("‚ÑπÔ∏è Debugger is already disabled.");const o=await t(s);try{await o.send("Debugger.disable"),i.enabled=!1,i.breakpoints.clear(),i.isPaused=!1,i.pausedCallFrames=void 0,n.appendResponseLine("‚úÖ Debugger disabled."),n.appendResponseLine("   All breakpoints have been removed.")}catch(e){n.appendResponseLine(`‚ùå Failed to disable debugger: ${e instanceof Error?e.message:String(e)}`)}}});export const getPossibleBreakpoints=g({name:"get_possible_breakpoints",description:'Discover all valid breakpoint locations in a script at a specific line.\n\nThis tool queries V8 for positions where breakpoints can actually be set, which is especially\nuseful for minified/single-line JavaScript where you need to find the exact column number.\n\nUse this before set_breakpoint to find valid positions, or when a breakpoint fails to resolve.\n\nExample:\n- Find breakpoints on line 1 of minified.js: urlRegex=".*minified\\.js.*", lineNumber=1\n- Find breakpoints in column range: urlRegex=".*app\\.js.*", lineNumber=10, startColumn=100, endColumn=200',annotations:{category:o.DEBUGGING,readOnlyHint:!0},schema:{urlRegex:n.string().describe('Regular expression to match the URL of the script file. Use ".*filename\\.js.*" pattern.'),lineNumber:n.number().int().positive().describe("The line number to search for breakpoints (1-based, as shown in editors)."),startColumn:n.number().int().nonnegative().optional().describe("Optional start column to filter results (0-based). Defaults to 0."),endColumn:n.number().int().nonnegative().optional().describe("Optional end column to filter results (0-based). Defaults to end of line."),maxCount:n.number().int().positive().optional().describe("Maximum number of locations to return. Defaults to 20.")},handler:async(e,n,t)=>{const{urlRegex:a,lineNumber:s,startColumn:i,endColumn:o,maxCount:p=20}=e.params,c=t.getSelectedPage(),u=await $(c);if(void 0!==i&&i<0)return n.appendResponseLine(`‚ùå Invalid startColumn: ${i}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Use startColumn=0 to search from the beginning of the line.");if(void 0!==o&&o<0)return n.appendResponseLine(`‚ùå Invalid endColumn: ${o}`),n.appendResponseLine("   Column numbers must be non-negative (0 or greater)."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Omit endColumn to search to the end of the line.");if(void 0!==i&&void 0!==o&&i>o)return n.appendResponseLine(`‚ùå Invalid column range: startColumn (${i}) > endColumn (${o})`),n.appendResponseLine("   startColumn must be less than or equal to endColumn."),n.appendResponseLine(""),void n.appendResponseLine("üí° Suggestion: Swap the values or adjust the range.");const d=s-1,m=await r(u,a);if(0===m.length)return n.appendResponseLine(`‚ùå No scripts found matching pattern: ${a}`),void n.appendResponseLine("   üí° Suggestion: Verify the script is loaded and the URL pattern is correct.");let b=[];for(const e of m){const n=i??0,t=o??n+100,a=(await l(u,e.scriptId,d,n,d,t,e.url)).filter(e=>!(void 0!==i&&e.columnNumber<i)&&!(void 0!==o&&e.columnNumber>o));b=b.concat(a)}if(0===b.length)return n.appendResponseLine(`‚ùå No valid breakpoint locations found at line ${s}`),void 0===i&&void 0===o||n.appendResponseLine(`   Column range: ${i??0} - ${o??"end"}`),void n.appendResponseLine("   üí° Suggestion: Try a different line or expand the column range.");b.sort((e,n)=>{const t=e.scriptUrl.localeCompare(n.scriptUrl);return 0!==t?t:e.columnNumber-n.columnNumber});const g=b.length,f=g>p,h=f?b.slice(0,p):b;n.appendResponseLine(`üìç Possible breakpoint locations at line ${s}:`),n.appendResponseLine(`   URL pattern: ${a}`),void 0===i&&void 0===o||n.appendResponseLine(`   Column range: ${i??0} - ${o??"end"}`),n.appendResponseLine("");for(const e of h)n.appendResponseLine(`   ${e.scriptUrl}:${e.lineNumber}:${e.columnNumber}`);f?(n.appendResponseLine(""),n.appendResponseLine(`‚ö†Ô∏è Results truncated: showing ${p} of ${g} locations`),n.appendResponseLine("   üí° Suggestion: Use startColumn/endColumn to narrow the search range.")):(n.appendResponseLine(""),n.appendResponseLine(`Found ${g} valid breakpoint location(s).`))}});export async function ensureDebuggerEnabledForPage(e){await $(e)}
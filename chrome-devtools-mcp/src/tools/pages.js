/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as a}from"../third_party/index.js";import{getDebuggerState as t,initializeDebuggerForPage as o}from"../utils/debuggerUtils.js";import{ToolCategory as n}from"./categories.js";import{CLOSE_PAGE_ERROR as s,defineTool as i,timeoutSchema as r}from"./ToolDefinition.js";export const listPages=i({name:"list_pages",description:"Get a list of pages open in the browser.",annotations:{category:n.NAVIGATION,readOnlyHint:!0},schema:{},handler:async(e,a)=>{a.setIncludePages(!0)}});export const selectPage=i({name:"select_page",description:"Select a page as a context for future tool calls.",annotations:{category:n.NAVIGATION,readOnlyHint:!0},schema:{pageIdx:a.number().describe(`The index of the page to select. Call ${listPages.name} to get available pages.`),bringToFront:a.boolean().optional().describe("Whether to focus the page and bring it to the top.")},handler:async(e,a,t)=>{const o=t.getPageByIdx(e.params.pageIdx);t.selectPage(o),a.setIncludePages(!0),e.params.bringToFront&&await o.bringToFront()}});export const closePage=i({name:"close_page",description:"Closes the page by its index. The last open page cannot be closed.",annotations:{category:n.NAVIGATION,readOnlyHint:!1},schema:{pageIdx:a.number().describe("The index of the page to close. Call list_pages to list pages.")},handler:async(e,a,t)=>{try{await t.closePage(e.params.pageIdx)}catch(e){if(e.message!==s)throw e;a.appendResponseLine(e.message)}a.setIncludePages(!0)}});export const newPage=i({name:"new_page",description:"Creates a new page",annotations:{category:n.NAVIGATION,readOnlyHint:!1},schema:{url:a.string().describe("URL to load in a new page."),incognito:a.boolean().optional().describe("Whether to open the page in a new incognito window."),newWindow:a.boolean().optional().describe("Whether to open the page in a new window."),userDataDir:a.string().optional().describe("Optional independent resource directory (user data directory). If provided, a new browser instance with its own window will be started."),enableDebugger:a.boolean().optional().describe("Whether to enable the JavaScript debugger for the new page. Default is true."),...r},handler:async(e,a,t)=>{const o=await t.newPage({incognito:e.params.incognito,newWindow:e.params.newWindow,userDataDir:e.params.userDataDir,enableDebugger:e.params.enableDebugger});await t.waitForEventsAfterAction(async()=>{await o.goto(e.params.url,{timeout:e.params.timeout})}),a.setIncludePages(!0)}});export const navigatePage=i({name:"navigate_page",description:"Navigates the currently selected page to a URL.",annotations:{category:n.NAVIGATION,readOnlyHint:!1},schema:{type:a.enum(["url","back","forward","reload"]).optional().describe("Navigate the page by URL, back or forward in history, or reload."),url:a.string().optional().describe("Target URL (only type=url)"),ignoreCache:a.boolean().optional().describe("Whether to ignore cache on reload."),enableDebugger:a.boolean().optional().describe("Whether to enable the JavaScript debugger after navigation. Default is true."),...r},handler:async(e,a,n)=>{const s=n.getSelectedPage(),i={timeout:e.params.timeout};if(!e.params.type&&!e.params.url)throw new Error("Either URL or a type is required.");if(e.params.type||(e.params.type="url"),!1===e.params.enableDebugger){t(s).userDisabled=!0}else!0===e.params.enableDebugger&&await o(s,{forceEnable:!0});await n.waitForEventsAfterAction(async()=>{switch(e.params.type){case"url":if(!e.params.url)throw new Error("A URL is required for navigation of type=url.");try{await s.goto(e.params.url,i),a.appendResponseLine(`Successfully navigated to ${e.params.url}.`)}catch(e){a.appendResponseLine(`Unable to navigate in the  selected page: ${e.message}.`)}break;case"back":try{await s.goBack(i),a.appendResponseLine(`Successfully navigated back to ${s.url()}.`)}catch(e){a.appendResponseLine(`Unable to navigate back in the selected page: ${e.message}.`)}break;case"forward":try{await s.goForward(i),a.appendResponseLine(`Successfully navigated forward to ${s.url()}.`)}catch(e){a.appendResponseLine(`Unable to navigate forward in the selected page: ${e.message}.`)}break;case"reload":try{await s.reload({...i,ignoreCache:e.params.ignoreCache}),a.appendResponseLine("Successfully reloaded the page.")}catch(e){a.appendResponseLine(`Unable to reload the selected page: ${e.message}.`)}}}),a.setIncludePages(!0)}});export const resizePage=i({name:"resize_page",description:"Resizes the selected page's window so that the page has specified dimension",annotations:{category:n.EMULATION,readOnlyHint:!1},schema:{width:a.number().describe("Page width"),height:a.number().describe("Page height")},handler:async(e,a,t)=>{const o=t.getSelectedPage();await o.resize({contentWidth:e.params.width,contentHeight:e.params.height}),a.setIncludePages(!0)}});export const handleDialog=i({name:"handle_dialog",description:"If a browser dialog was opened, use this command to handle it",annotations:{category:n.INPUT,readOnlyHint:!1},schema:{action:a.enum(["accept","dismiss"]).describe("Whether to dismiss or accept the dialog"),promptText:a.string().optional().describe("Optional prompt text to enter into the dialog.")},handler:async(a,t,o)=>{const n=o.getDialog();if(!n)throw new Error("No open dialog found");switch(a.params.action){case"accept":try{await n.accept(a.params.promptText)}catch(a){e(a)}t.appendResponseLine("Successfully accepted the dialog");break;case"dismiss":try{await n.dismiss()}catch(a){e(a)}t.appendResponseLine("Successfully dismissed the dialog")}o.clearDialog(),t.setIncludePages(!0)}});export const clearCookies=i({name:"clear_cookies",description:"Clear browser cookies for all sites or a specific domain.",annotations:{category:n.NAVIGATION,readOnlyHint:!1},schema:{url:a.string().optional().describe("Optional URL to clear cookies for a specific domain. If not provided, clears all cookies.")},handler:async(e,a,t)=>{const o=t.getSelectedPage(),n=o.browserContext();if(e.params.url){let t;try{const a=new URL(e.params.url);t=a.hostname}catch{return void a.appendResponseLine(`Failed to clear cookies: Invalid URL format "${e.params.url}".`)}try{const e=(await n.cookies()).filter(e=>e.domain===t||e.domain===`.${t}`||t.endsWith(e.domain.replace(/^\./,"")));if(0===e.length)return void a.appendResponseLine(`No cookies found for domain ${t}.`);for(const a of e)await o.deleteCookie(a);a.appendResponseLine(`Cleared ${e.length} cookie(s) for domain ${t}.`)}catch(e){a.appendResponseLine(`Failed to clear cookies: ${e.message}`)}}else try{const e=await n.cookies(),t=e.length;for(const a of e)await o.deleteCookie(a);a.appendResponseLine(`Cleared ${t} cookie(s) from browser.`)}catch(e){a.appendResponseLine(`Failed to clear cookies: ${e.message}`)}}});
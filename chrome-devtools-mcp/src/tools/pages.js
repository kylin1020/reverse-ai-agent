/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{zod as a}from"../third_party/index.js";import{ToolCategory as t}from"./categories.js";import{CLOSE_PAGE_ERROR as o,defineTool as s,timeoutSchema as n}from"./ToolDefinition.js";export const listPages=s({name:"list_pages",description:"Get a list of pages open in the browser.",annotations:{category:t.NAVIGATION,readOnlyHint:!0},schema:{},handler:async(e,a)=>{a.setIncludePages(!0)}});export const selectPage=s({name:"select_page",description:"Select a page as a context for future tool calls.",annotations:{category:t.NAVIGATION,readOnlyHint:!0},schema:{pageIdx:a.number().describe(`The index of the page to select. Call ${listPages.name} to get available pages.`),bringToFront:a.boolean().optional().describe("Whether to focus the page and bring it to the top.")},handler:async(e,a,t)=>{const o=t.getPageByIdx(e.params.pageIdx);t.selectPage(o),a.setIncludePages(!0),e.params.bringToFront&&await o.bringToFront()}});export const closePage=s({name:"close_page",description:"Closes the page by its index. The last open page cannot be closed.",annotations:{category:t.NAVIGATION,readOnlyHint:!1},schema:{pageIdx:a.number().describe("The index of the page to close. Call list_pages to list pages.")},handler:async(e,a,t)=>{try{await t.closePage(e.params.pageIdx)}catch(e){if(e.message!==o)throw e;a.appendResponseLine(e.message)}a.setIncludePages(!0)}});export const newPage=s({name:"new_page",description:"Creates a new page",annotations:{category:t.NAVIGATION,readOnlyHint:!1},schema:{url:a.string().describe("URL to load in a new page."),...n},handler:async(e,a,t)=>{const o=await t.newPage();await t.waitForEventsAfterAction(async()=>{await o.goto(e.params.url,{timeout:e.params.timeout})}),a.setIncludePages(!0)}});export const navigatePage=s({name:"navigate_page",description:"Navigates the currently selected page to a URL.",annotations:{category:t.NAVIGATION,readOnlyHint:!1},schema:{type:a.enum(["url","back","forward","reload"]).optional().describe("Navigate the page by URL, back or forward in history, or reload."),url:a.string().optional().describe("Target URL (only type=url)"),ignoreCache:a.boolean().optional().describe("Whether to ignore cache on reload."),...n},handler:async(e,a,t)=>{const o=t.getSelectedPage(),s={timeout:e.params.timeout};if(!e.params.type&&!e.params.url)throw new Error("Either URL or a type is required.");e.params.type||(e.params.type="url"),await t.waitForEventsAfterAction(async()=>{switch(e.params.type){case"url":if(!e.params.url)throw new Error("A URL is required for navigation of type=url.");try{await o.goto(e.params.url,s),a.appendResponseLine(`Successfully navigated to ${e.params.url}.`)}catch(e){a.appendResponseLine(`Unable to navigate in the  selected page: ${e.message}.`)}break;case"back":try{await o.goBack(s),a.appendResponseLine(`Successfully navigated back to ${o.url()}.`)}catch(e){a.appendResponseLine(`Unable to navigate back in the selected page: ${e.message}.`)}break;case"forward":try{await o.goForward(s),a.appendResponseLine(`Successfully navigated forward to ${o.url()}.`)}catch(e){a.appendResponseLine(`Unable to navigate forward in the selected page: ${e.message}.`)}break;case"reload":try{await o.reload({...s,ignoreCache:e.params.ignoreCache}),a.appendResponseLine("Successfully reloaded the page.")}catch(e){a.appendResponseLine(`Unable to reload the selected page: ${e.message}.`)}}}),a.setIncludePages(!0)}});export const resizePage=s({name:"resize_page",description:"Resizes the selected page's window so that the page has specified dimension",annotations:{category:t.EMULATION,readOnlyHint:!1},schema:{width:a.number().describe("Page width"),height:a.number().describe("Page height")},handler:async(e,a,t)=>{const o=t.getSelectedPage();await o.resize({contentWidth:e.params.width,contentHeight:e.params.height}),a.setIncludePages(!0)}});export const handleDialog=s({name:"handle_dialog",description:"If a browser dialog was opened, use this command to handle it",annotations:{category:t.INPUT,readOnlyHint:!1},schema:{action:a.enum(["accept","dismiss"]).describe("Whether to dismiss or accept the dialog"),promptText:a.string().optional().describe("Optional prompt text to enter into the dialog.")},handler:async(a,t,o)=>{const s=o.getDialog();if(!s)throw new Error("No open dialog found");switch(a.params.action){case"accept":try{await s.accept(a.params.promptText)}catch(a){e(a)}t.appendResponseLine("Successfully accepted the dialog");break;case"dismiss":try{await s.dismiss()}catch(a){e(a)}t.appendResponseLine("Successfully dismissed the dialog")}o.clearDialog(),t.setIncludePages(!0)}});export const clearCookies=s({name:"clear_cookies",description:"Clear browser cookies for all sites or a specific domain.",annotations:{category:t.NAVIGATION,readOnlyHint:!1},schema:{url:a.string().optional().describe("Optional URL to clear cookies for a specific domain. If not provided, clears all cookies.")},handler:async(e,a,t)=>{const o=t.getSelectedPage(),s=o.browserContext();if(e.params.url){let t;try{const a=new URL(e.params.url);t=a.hostname}catch{return void a.appendResponseLine(`Failed to clear cookies: Invalid URL format "${e.params.url}".`)}try{const e=(await s.cookies()).filter(e=>e.domain===t||e.domain===`.${t}`||t.endsWith(e.domain.replace(/^\./,"")));if(0===e.length)return void a.appendResponseLine(`No cookies found for domain ${t}.`);for(const a of e)await o.deleteCookie(a);a.appendResponseLine(`Cleared ${e.length} cookie(s) for domain ${t}.`)}catch(e){a.appendResponseLine(`Failed to clear cookies: ${e.message}`)}}else try{const e=await s.cookies(),t=e.length;for(const a of e)await o.deleteCookie(a);a.appendResponseLine(`Cleared ${t} cookie(s) from browser.`)}catch(e){a.appendResponseLine(`Failed to clear cookies: ${e.message}`)}}});
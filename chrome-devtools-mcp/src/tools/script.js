/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{zod as e}from"../third_party/index.js";import{getCdpSession as t}from"../utils/cdp.js";import{getConfig as n}from"../utils/config.js";import*as s from"../utils/persistentScripts.js";import{ToolCategory as r}from"./categories.js";import{defineTool as o}from"./ToolDefinition.js";let i=0;export const evaluateScript=o({name:"evaluate_script",description:"Evaluate a JavaScript function inside the currently selected page. Returns the response as JSON\nso returned values have to JSON-serializable.\n\n**Background Mode (background: true):**\nWhen enabled, the script executes without waiting for completion. This is essential when:\n- The script may hit breakpoints or contain `debugger` statements\n- You want to debug the script execution step-by-step\n- The script runs long-running operations\n\nIn background mode, use `get_debugger_status` to check if paused, and `resume`/`step_over`/`step_into`/`step_out` to control execution.\nResults are logged to console - use `get_console_logs` to retrieve them.\n\nNote: Background mode does not support element arguments (args parameter).\n\n**Persistent Mode (persistent: true):**\nWhen enabled, the script will be registered to execute automatically on every page load (including refreshes and navigations).\nThis is useful for:\n- Intercepting network requests (XMLHttpRequest, fetch)\n- Modifying global objects or prototypes\n- Setting up debugging hooks that survive page refreshes\n\nThe script executes before any other scripts on the page. Returns an identifier that can be used with persistent script management tools.\nNote: Persistent mode does not support element arguments (args parameter).",annotations:{category:r.DEBUGGING,readOnlyHint:!1},schema:{function:e.string().describe('A JavaScript function declaration to be executed in the currently selected page.\nExample without arguments: `() => {\n  return document.title\n}` or `async () => {\n  return await fetch("example.com")\n}`.\nExample with arguments: `(el) => {\n  return el.innerText;\n}`'),args:e.array(e.object({uid:e.string().describe("The uid of an element on the page from the page content snapshot")})).optional().describe("An optional list of arguments to pass to the function."),background:e.boolean().default(!1).optional().describe("When true, executes the script in background mode without waiting for completion. Useful when the script may trigger breakpoints or debugger statements. The script will still pause at breakpoints, but the tool call will return immediately. Default: false (synchronous execution)."),persistent:e.boolean().default(!1).optional().describe("When true, registers the script to execute automatically on every page load (including refreshes and navigations). The script executes before any other scripts on the page. Useful for persistent hooks like XHR/fetch interceptors. Returns an identifier for script management. Note: Does not support element arguments. Default: false."),scriptName:e.string().optional().describe("An optional name for the persistent script to help identify it when listing scripts. Only used when persistent is true.")},handler:async(e,r,o)=>{const{background:a,persistent:p,scriptName:c}=e.params,u=[];try{const l=new Set;for(const t of e.params.args??[]){const e=await o.getElementByUid(t.uid);l.add(e.frame),u.push(e)}let d;if(l.size>1)throw new Error("Elements from different frames can't be evaluated together.");if(d=[...l.values()][0]??o.getSelectedPage(),p){if(u.length>0)throw new Error("Persistent mode does not support element arguments. Use persistent mode only for scripts that do not require element references.");const t=o.getSelectedPage();try{const n=await s.addScript(t,e.params.function,c);r.appendResponseLine("✅ Persistent script registered successfully."),r.appendResponseLine(""),r.appendResponseLine(`**Identifier:** \`${n.identifier}\``),c&&r.appendResponseLine(`**Name:** ${c}`),r.appendResponseLine(""),r.appendResponseLine("The script will execute automatically before any other scripts on subsequent page loads."),r.appendResponseLine("Use `list_persistent_scripts` to see all registered scripts."),r.appendResponseLine("Use `remove_persistent_script` or `clear_persistent_scripts` to remove scripts.")}catch(e){const t=e instanceof Error?e.message:String(e);r.appendResponseLine("❌ Failed to register persistent script:"),r.appendResponseLine("```"),r.appendResponseLine(t),r.appendResponseLine("```")}return}if(a){if(u.length>0)throw new Error("Background mode does not support element arguments. Use background mode only for scripts that do not require element references.");const n=o.getSelectedPage(),s=await t(n),a=`bg_${Date.now()}_${++i}`,p=`\n          (async () => {\n            try {\n              const fn = (${e.params.function});\n              const result = await fn();\n              console.log('[Background Script Result]', JSON.stringify(result));\n              return result;\n            } catch (e) {\n              console.error('[Background Script Error]', e);\n              throw e;\n            }\n          })()\n        `,c=await s.send("Runtime.evaluate",{expression:p,awaitPromise:!1,returnByValue:!1,generatePreview:!1,userGesture:!0});if(c.exceptionDetails){const e=function(e){if(e.exception?.description)return e.exception.description;if(e.text){const t=void 0!==e.lineNumber?` at line ${e.lineNumber+1}:${(e.columnNumber??0)+1}`:"";return`${e.text}${t}`}return"Unknown error"}(c.exceptionDetails);return r.appendResponseLine("❌ Script failed to start:"),r.appendResponseLine("```"),r.appendResponseLine(e),r.appendResponseLine("```"),r.appendResponseLine(""),void r.appendResponseLine(`Execution ID: ${a}`)}return r.appendResponseLine("✅ Script started in background mode."),r.appendResponseLine(`Execution ID: ${a}`),r.appendResponseLine(""),r.appendResponseLine("The script is now running and may pause at breakpoints."),r.appendResponseLine("Use `get_debugger_status` to check if the script is paused."),r.appendResponseLine("Use `resume`, `step_over`, `step_into`, or `step_out` to control execution."),r.appendResponseLine("Script results will be logged to the console when complete."),void r.appendResponseLine("Use `get_console_logs` to view the results.")}const g=await d.evaluateHandle(`(${e.params.function})`);u.unshift(g),await o.waitForEventsAfterAction(async()=>{const e=await d.evaluate(async(e,...t)=>JSON.stringify(await e(...t)),...u);r.appendResponseLine("Script ran on page and returned:"),r.appendResponseLine("```json"),r.appendResponseLine(function(e){const t=n().maxBodySize;return e.length>t?e.substring(0,t)+"\n... <truncated>":e}(e)),r.appendResponseLine("```")})}finally{Promise.allSettled(u.map(e=>e.dispose()))}}});
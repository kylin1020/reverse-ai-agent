/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{zod as e}from"../third_party/index.js";import{getCdpSession as n}from"../utils/cdp.js";import{getConfig as t}from"../utils/config.js";import{ToolCategory as o}from"./categories.js";import{defineTool as s}from"./ToolDefinition.js";let r=0;export const evaluateScript=s({name:"evaluate_script",description:"Evaluate a JavaScript function inside the currently selected page. Returns the response as JSON\nso returned values have to JSON-serializable.\n\n**Background Mode (background: true):**\nWhen enabled, the script executes without waiting for completion. This is essential when:\n- The script may hit breakpoints or contain `debugger` statements\n- You want to debug the script execution step-by-step\n- The script runs long-running operations\n\nIn background mode, use `get_debugger_status` to check if paused, and `resume`/`step_over`/`step_into`/`step_out` to control execution.\nResults are logged to console - use `get_console_logs` to retrieve them.\n\nNote: Background mode does not support element arguments (args parameter).",annotations:{category:o.DEBUGGING,readOnlyHint:!1},schema:{function:e.string().describe('A JavaScript function declaration to be executed in the currently selected page.\nExample without arguments: `() => {\n  return document.title\n}` or `async () => {\n  return await fetch("example.com")\n}`.\nExample with arguments: `(el) => {\n  return el.innerText;\n}`'),args:e.array(e.object({uid:e.string().describe("The uid of an element on the page from the page content snapshot")})).optional().describe("An optional list of arguments to pass to the function."),background:e.boolean().default(!1).optional().describe("When true, executes the script in background mode without waiting for completion. Useful when the script may trigger breakpoints or debugger statements. The script will still pause at breakpoints, but the tool call will return immediately. Default: false (synchronous execution).")},handler:async(e,o,s)=>{const{background:a}=e.params,i=[];try{const p=new Set;for(const n of e.params.args??[]){const e=await s.getElementByUid(n.uid);p.add(e.frame),i.push(e)}let c;if(p.size>1)throw new Error("Elements from different frames can't be evaluated together.");if(c=[...p.values()][0]??s.getSelectedPage(),a){if(i.length>0)throw new Error("Background mode does not support element arguments. Use background mode only for scripts that do not require element references.");const t=s.getSelectedPage(),a=await n(t),p=`bg_${Date.now()}_${++r}`,c=`\n          (async () => {\n            try {\n              const fn = (${e.params.function});\n              const result = await fn();\n              console.log('[Background Script Result]', JSON.stringify(result));\n              return result;\n            } catch (e) {\n              console.error('[Background Script Error]', e);\n              throw e;\n            }\n          })()\n        `,u=await a.send("Runtime.evaluate",{expression:c,awaitPromise:!1,returnByValue:!1,generatePreview:!1,userGesture:!0});if(u.exceptionDetails){const e=function(e){if(e.exception?.description)return e.exception.description;if(e.text){const n=void 0!==e.lineNumber?` at line ${e.lineNumber+1}:${(e.columnNumber??0)+1}`:"";return`${e.text}${n}`}return"Unknown error"}(u.exceptionDetails);return o.appendResponseLine("❌ Script failed to start:"),o.appendResponseLine("```"),o.appendResponseLine(e),o.appendResponseLine("```"),o.appendResponseLine(""),void o.appendResponseLine(`Execution ID: ${p}`)}return o.appendResponseLine("✅ Script started in background mode."),o.appendResponseLine(`Execution ID: ${p}`),o.appendResponseLine(""),o.appendResponseLine("The script is now running and may pause at breakpoints."),o.appendResponseLine("Use `get_debugger_status` to check if the script is paused."),o.appendResponseLine("Use `resume`, `step_over`, `step_into`, or `step_out` to control execution."),o.appendResponseLine("Script results will be logged to the console when complete."),void o.appendResponseLine("Use `get_console_logs` to view the results.")}const u=await c.evaluateHandle(`(${e.params.function})`);i.unshift(u),await s.waitForEventsAfterAction(async()=>{const e=await c.evaluate(async(e,...n)=>JSON.stringify(await e(...n)),...i);o.appendResponseLine("Script ran on page and returned:"),o.appendResponseLine("```json"),o.appendResponseLine(function(e){const n=t().maxBodySize;return e.length>n?e.substring(0,n)+"\n... <truncated>":e}(e)),o.appendResponseLine("```")})}finally{Promise.allSettled(i.map(e=>e.dispose()))}}});
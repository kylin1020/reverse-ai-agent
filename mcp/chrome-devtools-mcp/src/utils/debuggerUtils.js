/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import{logger as e}from"../logger.js";import{clearParseResultCache as t}from"../tools/analysis.js";import{getCdpSession as r}from"./cdp.js";import{cacheScript as a,clearScriptCache as n}from"./smartBreakpointUtils.js";const o=new WeakMap;export function getDebuggerState(e){let t=o.get(e);return t||(t={enabled:!1,isPaused:!1,activeBreakpointIds:new Set,userDisabled:!1},o.set(e,t)),t}export async function getActiveBreakpoints(e){const t=getDebuggerState(e),a=(await r(e),[]),n=[];for(const e of t.activeBreakpointIds)try{const t=e.split(":");if(t.length>=4){const r=parseInt(t[0],10)+1,n=parseInt(t[1],10),o=t.slice(3).join(":");a.push({breakpointId:e,url:o,lineNumber:r,columnNumber:n})}else a.push({breakpointId:e,url:"(unknown)",lineNumber:0,columnNumber:0})}catch{n.push(e)}for(const e of n)t.activeBreakpointIds.delete(e);return a}export function trackBreakpoint(e,t){getDebuggerState(e).activeBreakpointIds.add(t)}export function untrackBreakpoint(e,t){getDebuggerState(e).activeBreakpointIds.delete(t)}export function getBreakpointCount(e){return getDebuggerState(e).activeBreakpointIds.size}export function clearTrackedBreakpoints(e){getDebuggerState(e).activeBreakpointIds.clear()}const i=new WeakSet;export async function restoreBreakpointsAfterNavigation(t,r){const a=getDebuggerState(t);if(a.userDisabled)e("[debugger] Debugger was explicitly disabled by user, skipping re-enable after navigation");else try{await r.send("Debugger.enable"),a.enabled=!0,e("[debugger] Debugger re-enabled after navigation")}catch{}}export async function initializeDebuggerForPage(o,s){const c=await r(o),u=getDebuggerState(o);if(s?.forceEnable&&(u.userDisabled=!1),u.userDisabled)return c;if(u.enabled||(await c.send("Debugger.enable"),u.enabled=!0,c.on("Debugger.scriptParsed",async t=>{const r=t.scriptId,n=t.url||"";a(c,{scriptId:r,url:n,startLine:t.startLine,startColumn:t.startColumn,endLine:t.endLine,endColumn:t.endColumn}),e(`[debugger] Script parsed: ${n||r}`)}),c.on("Debugger.paused",t=>{u.isPaused=!0,u.pausedCallFrames=t.callFrames?.map(e=>({callFrameId:e.callFrameId,functionName:e.functionName||"(anonymous)",location:{scriptId:e.location.scriptId,lineNumber:e.location.lineNumber,columnNumber:e.location.columnNumber},url:e.url||"",scopeChain:e.scopeChain?.map(e=>({type:e.type,object:{type:e.object?.type,objectId:e.object?.objectId},name:e.name}))||[]})),e("[debugger] Execution paused at breakpoint")}),c.on("Debugger.resumed",()=>{u.isPaused=!1,u.pausedCallFrames=void 0,e("[debugger] Execution resumed")})),!i.has(o)){let r;i.add(o);try{const e=await c.send("Page.getFrameTree");r=e.frameTree?.frame?.id}catch{}c.on("Page.frameStartedLoading",async a=>{let i=!r||a.frameId===r;if(!i)try{const e=await c.send("Page.getFrameTree"),t=e.frameTree?.frame?.id;a.frameId===t&&(i=!0,r=t)}catch{i=!0}if(i){n(c),t(c),e("[debugger] Script cache and parse result cache cleared on navigation"),e("[debugger] Main frame started loading, initializing debugger/breakpoints...");try{await restoreBreakpointsAfterNavigation(o,c)}catch(t){e(`[debugger] Error restoring breakpoints: ${t}`)}try{const e=await c.send("Page.getFrameTree");r=e.frameTree?.frame?.id}catch{}}});try{await c.send("Page.enable")}catch{}}return c}export async function getBreakpointSummary(e){const t=await getActiveBreakpoints(e),r=[];if(0===t.length)return r;r.push(`ðŸ”´ Active breakpoints (${t.length}):`);for(const e of t){const t=`line ${e.lineNumber}, col ${e.columnNumber}`,a=e.condition?` [condition: ${e.condition}]`:"";r.push(`   â€¢ ${e.breakpointId}: ${e.url} @ ${t}${a}`)}return r}const s=new WeakMap;export function trackXhrBreakpoint(e,t){let r=s.get(e);r||(r=new Set,s.set(e,r)),r.add(t)}export function untrackXhrBreakpoint(e,t){const r=s.get(e);return!!r&&r.delete(t)}export function getTrackedXhrBreakpoints(e){const t=s.get(e);return t?Array.from(t):[]}export function clearTrackedXhrBreakpoints(e){const t=s.get(e);t&&t.clear()}
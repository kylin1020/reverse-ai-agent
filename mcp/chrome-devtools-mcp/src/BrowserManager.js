/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import t from"node:fs";import e from"node:os";import{browserStatusManager as s,getChromeExecutablePath as r,getSelfCdpUrl as n,getCdpTargets as o,buildBrowserArgs as i,createTempPersistentContextDir as a,cleanupPersistentContextDir as c,cleanupOldLogFiles as h}from"./BrowserManager_utils.js";import{logger as w}from"./logger.js";import{puppeteer as p}from"./third_party/index.js";export async function listBrowserContexts(t){try{const e=new URL(t),s=parseInt(e.port||"9222",10),r=await o(s),n=new Map;for(const t of r)if("page"===t.type){const e=t.id;n.set(e,(n.get(e)||0)+1)}return Array.from(n.entries()).map(([t,e])=>({id:t,pages:e}))}catch(t){return w(`Error listing browser contexts: ${t}`),[]}}export class BrowserManager{options;browser=null;browserContext=null;activeBrowsers=new Set;persistentContextDir=null;isDisposed=!1;constructor(t){this.options=t}async getBrowser(){if(this.isDisposed)throw new Error("BrowserManager has been disposed");if(this.browser?.connected)return this.browser;w("Lazily initializing browser"),s.setStatus({type:"connecting"});try{return this.browser=await this.connectOrLaunch(),this.activeBrowsers.add(this.browser),this.setupBrowserEventHandlers(this.browser),s.setStatus({type:"connected"}),this.browser}catch(t){const e=t instanceof Error?t.message:String(t);throw s.setStatus({type:"error",error:e}),t}}async getPage(){const t=await this.getBrowser(),e=await t.pages();return e.length>0&&e[0]?e[0]:await t.newPage()}async getPages(){const t=await this.getBrowser();return await t.pages()}async connectOrLaunch(){const{config:t}=this.options;switch(t.connectionType){case"self":return await this.connectToSelf();case"cdp":return await this.connectToCdp(t.cdpUrl);case"executable":return await this.launchWithExecutable(t.executablePath);default:return await this.launchDefault()}}async connectToSelf(){const t=await n();w(`Connecting to self CDP at ${t}`);const e=await p.connect({browserWSEndpoint:t,defaultViewport:this.options.viewport??null});return w("Connected to self CDP endpoint"),e}async connectToCdp(t){w(`Connecting to CDP at ${t}`);const e=await p.connect({browserWSEndpoint:t,defaultViewport:this.options.viewport??null});return w("Connected to CDP endpoint"),e}async launchWithExecutable(t){return w(`Launching browser with executable: ${t}`),await this.launchBrowser(t)}async launchDefault(){const t=await r();return t?(w(`Found Chrome executable at: ${t}`),await this.launchBrowser(t)):(w("Using bundled Chrome"),await this.launchBrowser(void 0,"chrome"))}async launchBrowser(e,r){s.setStatus({type:"launching"}),this.options.storageDir?(this.persistentContextDir=this.options.storageDir,w(`Using provided persistent context directory: ${this.persistentContextDir}`)):(this.persistentContextDir=await a(),w(`Using temporary persistent context directory: ${this.persistentContextDir}`)),this.persistentContextDir&&await t.promises.mkdir(this.persistentContextDir,{recursive:!0});const n=i({headless:this.options.headless,devtools:this.options.devtools,additionalArgs:this.options.additionalArgs,noSandbox:this.options.noSandbox}),o={headless:!!this.options.headless&&"new",defaultViewport:this.options.viewport??null,userDataDir:this.persistentContextDir??void 0,args:n,acceptInsecureCerts:this.options.acceptInsecureCerts,pipe:!0,executablePath:e||void 0,channel:e?void 0:r};try{const t=await p.launch(o);return w(`Browser launched with persistent context at: ${this.persistentContextDir}`),t}catch(t){if(this.persistentContextDir&&t.message.includes("The browser is already running"))throw new Error(`The browser is already running for ${this.persistentContextDir}. Use a different storage directory or close the existing browser.`,{cause:t});throw t}}setupBrowserEventHandlers(t){t.on("disconnected",()=>{w("Browser disconnected"),this.activeBrowsers.delete(t),this.browser===t&&(this.browser=null,this.browserContext=null,s.setStatus({type:"disconnected"}))})}isConnected(){return this.browser?.connected??!1}getStatus(){return s.getStatus()}async dispose(){if(!this.isDisposed){if(this.isDisposed=!0,w("Disposing BrowserManager"),this.browserContext){try{await this.browserContext.close(),w("Browser context closed")}catch(t){w(`Error closing browser context: ${t}`)}this.browserContext=null}if(this.activeBrowsers.size>0){w(`Closing ${this.activeBrowsers.size} active browser(s)`);const t=Array.from(this.activeBrowsers).map(async t=>{try{await t.close(),w("Browser closed")}catch(t){w(`Error closing browser: ${t}`)}});await Promise.allSettled(t),this.activeBrowsers.clear()}this.browser=null,this.persistentContextDir&&!this.options.storageDir&&await c(this.persistentContextDir),this.persistentContextDir=null,await h(),s.setStatus({type:"disconnected"}),w("BrowserManager disposed")}}}export function createDefaultBrowserManager(t){return new BrowserManager({config:{connectionType:"default"},...t})}export function createCdpBrowserManager(t,e){return new BrowserManager({config:{connectionType:"cdp",cdpUrl:t},...e})}export function createExecutableBrowserManager(t,e){return new BrowserManager({config:{connectionType:"executable",executablePath:t},...e})}export async function checkBrowserStatus(){const t=await r();return{platform:e.platform(),chromeFound:!!t,chromePath:t||"bundled",status:s.getStatus()}}